
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>lsqfit - Nonlinear Least Squares Fitting &#8212; lsqfit 11.2 documentation</title>
    <link rel="stylesheet" href="_static/pyramid.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <script type="text/javascript" src="_static/documentation_options.js"></script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" />
    <link rel="next" title="GSL Routines" href="gsl.html" />
    <link rel="prev" title="Case Study: Outliers and Bayesian Integrals" href="case-outliers.html" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Neuton&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Nobile:regular,italic,bold,bolditalic&amp;subset=latin" type="text/css" media="screen" charset="utf-8" />
<!--[if lte IE 6]>
<link rel="stylesheet" href="_static/ie6.css" type="text/css" media="screen" charset="utf-8" />
<![endif]-->

  </head><body>

    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="gsl.html" title="GSL Routines"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="case-outliers.html" title="Case Study: Outliers and Bayesian Integrals"
             accesskey="P">previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">lsqfit 11.2 documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="lsqfit-nonlinear-least-squares-fitting">
<h1><a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code></a> - Nonlinear Least Squares Fitting<a class="headerlink" href="#lsqfit-nonlinear-least-squares-fitting" title="Permalink to this headline">¶</a></h1>
<span class="target" id="module-lsqfit"></span><div class="section" id="introduction">
<h2>Introduction<a class="headerlink" href="#introduction" title="Permalink to this headline">¶</a></h2>
<p>This package contains tools for nonlinear least-squares curve fitting of
data. In general a fit has four inputs:</p>
<blockquote>
<div><ol class="arabic simple">
<li>The dependent data <code class="docutils literal notranslate"><span class="pre">y</span></code> that is to be fit — typically <code class="docutils literal notranslate"><span class="pre">y</span></code>
is a Python dictionary in an <a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code></a> analysis. Its values
<code class="docutils literal notranslate"><span class="pre">y[k]</span></code> are either <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s or arrays (any shape or dimension) of
<code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s that specify the values of the dependent variables
and their errors.</li>
<li>A collection <code class="docutils literal notranslate"><span class="pre">x</span></code> of independent data — <code class="docutils literal notranslate"><span class="pre">x</span></code> can have any
structure and contain any data, or it can be omitted.</li>
<li>A fit function <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">p)</span></code> whose parameters <code class="docutils literal notranslate"><span class="pre">p</span></code> are adjusted by
the fit until <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">p)</span></code> equals <code class="docutils literal notranslate"><span class="pre">y</span></code> to within <code class="docutils literal notranslate"><span class="pre">y</span></code>s errors
— parameters <cite>p`</cite> are usually specified by a dictionary whose
values <code class="docutils literal notranslate"><span class="pre">p[k]</span></code> are individual parameters or (<code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code>)
arrays of parameters. The fit function is assumed independent
of <code class="docutils literal notranslate"><span class="pre">x</span></code> (that is, <code class="docutils literal notranslate"><span class="pre">f(p)</span></code>) if <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">=</span> <span class="pre">False</span></code> (or if <code class="docutils literal notranslate"><span class="pre">x</span></code> is
omitted from the input data).</li>
<li>Initial estimates or <em>priors</em> for each parameter in <code class="docutils literal notranslate"><span class="pre">p</span></code>
— priors are usually specified using a dictionary <code class="docutils literal notranslate"><span class="pre">prior</span></code>
whose values <code class="docutils literal notranslate"><span class="pre">prior[k]</span></code> are <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s or arrays of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s that
give initial estimates (values and errors) for parameters <code class="docutils literal notranslate"><span class="pre">p[k]</span></code>.</li>
</ol>
</div></blockquote>
<p>A typical code sequence has the structure:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span> <span class="n">collect</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">,</span> <span class="n">prior</span> <span class="o">...</span>

<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="o">...</span> <span class="n">compute</span> <span class="n">fit</span> <span class="n">to</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">],</span> <span class="k">for</span> <span class="nb">all</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">y</span><span class="p">,</span> <span class="n">using</span> <span class="n">x</span><span class="p">,</span> <span class="n">p</span> <span class="o">...</span>
    <span class="o">...</span> <span class="k">return</span> <span class="n">dictionary</span> <span class="n">containing</span> <span class="n">the</span> <span class="n">fit</span> <span class="n">values</span> <span class="k">for</span> <span class="n">the</span> <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">]</span><span class="n">s</span> <span class="o">...</span>

<span class="n">fit</span> <span class="o">=</span> <span class="n">lsqfit</span><span class="o">.</span><span class="n">nonlinear_fit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">fcn</span><span class="o">=</span><span class="n">f</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>      <span class="c1"># variable fit is of type nonlinear_fit</span>
</pre></div>
</div>
<p>The parameters <code class="docutils literal notranslate"><span class="pre">p[k]</span></code> are varied until the <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> for the fit is
minimized.</p>
<p>The best-fit values for the parameters are recovered after fitting
using, for example, <code class="docutils literal notranslate"><span class="pre">p=fit.p</span></code>. Then the <code class="docutils literal notranslate"><span class="pre">p[k]</span></code> are <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s or
arrays of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s that give best-fit estimates and fit uncertainties
in those estimates. The <code class="docutils literal notranslate"><span class="pre">print(fit)</span></code> statement prints a summary of
the fit results.</p>
<p>The dependent variable <code class="docutils literal notranslate"><span class="pre">y</span></code> above could be an array instead of a
dictionary, which is less flexible in general but possibly more
convenient in simpler fits. Then the approximate <code class="docutils literal notranslate"><span class="pre">y</span></code> returned by fit
function <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">p)</span></code> must be an array with the same shape as the dependent
variable. The prior <code class="docutils literal notranslate"><span class="pre">prior</span></code> could also be represented by an array
instead of a dictionary.</p>
<p>By default priors are Gaussian/normal distributions, represented by
<code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s. <a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code></a> also
allows for log-normal and other distributions as well. The
latter are indicated by replacing the prior (in a dictionary prior)
with key <code class="docutils literal notranslate"><span class="pre">c</span></code>,  for example, by a prior for the parameter’s logarithm,
with key <code class="docutils literal notranslate"><span class="pre">log(c)</span></code>.
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">nonlinear_fit</span></code></a> in effect adds parameter <code class="docutils literal notranslate"><span class="pre">c</span></code> to the parameter
dictionary, deriving its value from parameter <code class="docutils literal notranslate"><span class="pre">log(c)</span></code>.
The fit function can be expressed directly in terms of
parameter <code class="docutils literal notranslate"><span class="pre">c</span></code>  and so is the same no matter which distribution is
used for <code class="docutils literal notranslate"><span class="pre">c</span></code>. Additional distributions
can be added using <code class="xref py py-meth docutils literal notranslate"><span class="pre">gvar.BufferDict.add_distribution()</span></code>.</p>
<p>The <a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code></a> tutorial contains extended explanations and examples.
The first appendix in the paper at <a class="reference external" href="http://arxiv.org/abs/arXiv:1406.2279">http://arxiv.org/abs/arXiv:1406.2279</a>
provides conceptual background on the techniques used in this
module for fits and, especially, error budgets.</p>
</div>
<div class="section" id="nonlinear-fit-objects">
<h2>nonlinear_fit Objects<a class="headerlink" href="#nonlinear-fit-objects" title="Permalink to this headline">¶</a></h2>
<dl class="class">
<dt id="lsqfit.nonlinear_fit">
<em class="property">class </em><code class="descclassname">lsqfit.</code><code class="descname">nonlinear_fit</code><span class="sig-paren">(</span><em>data</em>, <em>fcn</em>, <em>prior=None</em>, <em>p0=None</em>, <em>svdcut=1e-12</em>, <em>add_svdnoise=False</em>, <em>add_priornoise=False</em>, <em>debug=False</em>, <em>tol=1e-8</em>, <em>maxit=1000</em>, <em>fitter='gsl_multifit'</em>, <em>**fitterargs</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Nonlinear least-squares fit.</p>
<p><a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> fits a (nonlinear) function <code class="docutils literal notranslate"><span class="pre">f(x,</span> <span class="pre">p)</span></code>
to data <code class="docutils literal notranslate"><span class="pre">y</span></code> by varying parameters <code class="docutils literal notranslate"><span class="pre">p</span></code>, and stores the results: for
example,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fit</span> <span class="o">=</span> <span class="n">nonlinear_fit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">),</span> <span class="n">fcn</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">)</span>   <span class="c1"># do fit</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>                               <span class="c1"># print fit results</span>
</pre></div>
</div>
<p>The best-fit values for the parameters are in <code class="docutils literal notranslate"><span class="pre">fit.p</span></code>, while the
<code class="docutils literal notranslate"><span class="pre">chi**2</span></code>, the number of degrees of freedom, the logarithm of Gaussian
Bayes Factor, the number of iterations (or function evaluations),  and the
cpu time needed for the fit are in <code class="docutils literal notranslate"><span class="pre">fit.chi2</span></code>, <code class="docutils literal notranslate"><span class="pre">fit.dof</span></code>,
<code class="docutils literal notranslate"><span class="pre">fit.logGBF</span></code>, <code class="docutils literal notranslate"><span class="pre">fit.nit</span></code>, and <code class="docutils literal notranslate"><span class="pre">fit.time</span></code>, respectively. Results for
individual parameters in <code class="docutils literal notranslate"><span class="pre">fit.p</span></code> are of type <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>, and therefore carry
information about errors and correlations with other parameters. The fit
data and prior can be recovered using <code class="docutils literal notranslate"><span class="pre">fit.x</span></code> (equals <code class="docutils literal notranslate"><span class="pre">False</span></code> if there
is no <code class="docutils literal notranslate"><span class="pre">x</span></code>), <code class="docutils literal notranslate"><span class="pre">fit.y</span></code>, and <code class="docutils literal notranslate"><span class="pre">fit.prior</span></code>; the data and prior are
corrected for the SVD cut, if there is one (that is, their covariance
matrices have been modified in accordance with the SVD cut).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> (<em>dict</em><em>, </em><em>array</em><em> or </em><em>tuple</em>) – <p>Data to be fit by <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a>
can have any of the following forms:</p>
<blockquote>
<div><dl class="docutils">
<dt><code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">y</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">x</span></code> is the independent data that is passed to the fit
function with the fit parameters: <code class="docutils literal notranslate"><span class="pre">fcn(x,</span> <span class="pre">p)</span></code>. <code class="docutils literal notranslate"><span class="pre">y</span></code> is a
dictionary (or array) of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s that encode the means and
covariance matrix for the data that is to be fit being fit.
The fit function must return a result having the same
layout as <code class="docutils literal notranslate"><span class="pre">y</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">=</span> <span class="pre">y</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">y</span></code> is a dictionary (or array) of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s that encode
the means and covariance matrix for the data being fit.
There is no independent data so the fit function depends
only upon the fit parameters: <code class="docutils literal notranslate"><span class="pre">fit(p)</span></code>. The fit function
must return a result having the same layout as <code class="docutils literal notranslate"><span class="pre">y</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">ymean,</span> <span class="pre">ycov</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">x</span></code> is the independent data that is passed to the fit
function with the fit parameters: <code class="docutils literal notranslate"><span class="pre">fcn(x,</span> <span class="pre">p)</span></code>. <code class="docutils literal notranslate"><span class="pre">ymean</span></code>
is an array containing the mean values of the fit data.
<code class="docutils literal notranslate"><span class="pre">ycov</span></code> is an array containing the covariance matrix of
the fit data; <code class="docutils literal notranslate"><span class="pre">ycov.shape</span></code> equals <code class="docutils literal notranslate"><span class="pre">2*ymean.shape</span></code>.
The fit function must return an array having the same
shape as <code class="docutils literal notranslate"><span class="pre">ymean</span></code>.</dd>
<dt><code class="docutils literal notranslate"><span class="pre">data</span> <span class="pre">=</span> <span class="pre">x,</span> <span class="pre">ymean,</span> <span class="pre">ysdev</span></code></dt>
<dd><code class="docutils literal notranslate"><span class="pre">x</span></code> is the independent data that is passed to the fit
function with the fit parameters: <code class="docutils literal notranslate"><span class="pre">fcn(x,</span> <span class="pre">p)</span></code>. <code class="docutils literal notranslate"><span class="pre">ymean</span></code>
is an array containing the mean values of the fit data.
<code class="docutils literal notranslate"><span class="pre">ysdev</span></code> is an array containing the standard deviations of
the fit data; <code class="docutils literal notranslate"><span class="pre">ysdev.shape</span></code> equals <code class="docutils literal notranslate"><span class="pre">ymean.shape</span></code>. The
data are assumed to be uncorrelated. The fit function must
return an array having the same shape as <code class="docutils literal notranslate"><span class="pre">ymean</span></code>.</dd>
</dl>
</div></blockquote>
<p>Setting <code class="docutils literal notranslate"><span class="pre">x=False</span></code> in the first, third or fourth of these formats
implies that the fit function depends only on the fit parameters:
that is, <code class="docutils literal notranslate"><span class="pre">fcn(p)</span></code> instead of <code class="docutils literal notranslate"><span class="pre">fcn(x,</span> <span class="pre">p)</span></code>. (This is not assumed
if <code class="docutils literal notranslate"><span class="pre">x=None</span></code>.)</p>
</li>
<li><strong>fcn</strong> (<em>callable</em>) – The function to be fit to <code class="docutils literal notranslate"><span class="pre">data</span></code>. It is either a
function of the independent data <code class="docutils literal notranslate"><span class="pre">x</span></code> and the fit parameters <code class="docutils literal notranslate"><span class="pre">p</span></code>
(<code class="docutils literal notranslate"><span class="pre">fcn(x,</span> <span class="pre">p)</span></code>), or a function of just the fit parameters
(<code class="docutils literal notranslate"><span class="pre">fcn(p)</span></code>) when there is no <code class="docutils literal notranslate"><span class="pre">x</span></code> data or <code class="docutils literal notranslate"><span class="pre">x=False</span></code>. The
parameters are tuned in the fit until the function returns values
that agree with the <code class="docutils literal notranslate"><span class="pre">y</span></code> data to within the <code class="docutils literal notranslate"><span class="pre">y</span></code>s’ errors. The
function’s return value must have the same layout as the <code class="docutils literal notranslate"><span class="pre">y</span></code> data
(a dictionary or an array). The fit parameters <code class="docutils literal notranslate"><span class="pre">p</span></code> are either: 1)
a dictionary where each <code class="docutils literal notranslate"><span class="pre">p[k]</span></code> is a single parameter or an array
of parameters (any shape); or, 2) a single array of parameters. The
layout of the parameters is the same as that of prior <code class="docutils literal notranslate"><span class="pre">prior</span></code> if
it is specified; otherwise, it is inferred from of the starting
value <code class="docutils literal notranslate"><span class="pre">p0</span></code> for the fit.</li>
<li><strong>prior</strong> (<em>dict</em><em>, </em><em>array</em><em>, </em><em>str</em><em>, </em><em>gvar.GVar</em><em> or </em><em>None</em>) – A dictionary (or array)
containing <em>a priori</em> estimates for all parameters <code class="docutils literal notranslate"><span class="pre">p</span></code> used by
fit function <code class="docutils literal notranslate"><span class="pre">fcn(x,</span> <span class="pre">p)</span></code> (or <code class="docutils literal notranslate"><span class="pre">fcn(p)</span></code>). Fit parameters <code class="docutils literal notranslate"><span class="pre">p</span></code>
are stored in a dictionary (or array) with the same keys and
structure (or shape) as <code class="docutils literal notranslate"><span class="pre">prior</span></code>. The default value is <code class="docutils literal notranslate"><span class="pre">None</span></code>;
<code class="docutils literal notranslate"><span class="pre">prior</span></code> must be defined if <code class="docutils literal notranslate"><span class="pre">p0</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</li>
<li><strong>p0</strong> (<em>dict</em><em>, </em><em>array</em><em>, </em><em>float</em><em>, </em><em>None</em><em>, or </em><em>True</em>) – Starting values for fit
parameters in fit. <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> adjusts <code class="docutils literal notranslate"><span class="pre">p0</span></code> to
make it consistent in shape and structure with <code class="docutils literal notranslate"><span class="pre">prior</span></code> when the
latter is specified: elements missing from <code class="docutils literal notranslate"><span class="pre">p0</span></code> are filled in
using <code class="docutils literal notranslate"><span class="pre">prior</span></code>, and elements in <code class="docutils literal notranslate"><span class="pre">p0</span></code> that are not in <code class="docutils literal notranslate"><span class="pre">prior</span></code>
are discarded. If <code class="docutils literal notranslate"><span class="pre">p0</span></code> is a string, it is taken as a file name
and <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> attempts to read starting values
from that file; best-fit parameter values are written out to the
same file after the fit (for priming future fits). If <code class="docutils literal notranslate"><span class="pre">p0</span></code> is
<code class="docutils literal notranslate"><span class="pre">None</span></code> or the attempt to read the file fails, starting values
are extracted from <code class="docutils literal notranslate"><span class="pre">prior</span></code>. If <code class="docutils literal notranslate"><span class="pre">p0</span></code> is <code class="docutils literal notranslate"><span class="pre">True</span></code>, it
is replaced by a starting point drawn at random from the
<code class="docutils literal notranslate"><span class="pre">prior</span></code> distribution. The default value is <code class="docutils literal notranslate"><span class="pre">None</span></code>;
<code class="docutils literal notranslate"><span class="pre">p0</span></code> must be explicitly specified if <code class="docutils literal notranslate"><span class="pre">prior</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>.</li>
<li><strong>linear</strong> (<em>list</em><em> or </em><em>None</em>) – Optional list of fit parameters that appear
linearly in the fit function. The fit function can be reexpressed
(using <em>variable projection</em>) as a function that is independent of
its linear parameters. The resulting fit has fewer fit parameters
and typically will converge in fewer iterations, but each
iteration will take longer. Whether or not the fit is faster or
more robust in any particular application is a matter for
experiment, but answers should be the same either way. The linear
parameters are reconstructed from the nonlinear parameters (and
the data) after the fit. Parameter <code class="docutils literal notranslate"><span class="pre">linear</span></code> is either: a list of
dictionary keys corresponding to linear parameters when the
parameters are stored in a dictionary (see <code class="docutils literal notranslate"><span class="pre">prior</span></code>); or, a list
of indices corresponding to these parameters when they are stored
in an array. Note that this feature is experimental; the
interface may change in the future.</li>
<li><strong>svdcut</strong> (<em>float</em><em>, </em><em>dict</em><em>, </em><em>None</em>) – If <code class="docutils literal notranslate"><span class="pre">svdcut</span></code> is a nonzero number,
SVD cuts are applied to every block-diagonal sub-matrix of the
correlation matrix for the data <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">prior</span></code> (if there is a
prior). If <code class="docutils literal notranslate"><span class="pre">svdcut</span> <span class="pre">&gt;</span> <span class="pre">0</span></code>, eigenvalues of the rescaled matrices
that are smaller than <code class="docutils literal notranslate"><span class="pre">svdcut</span></code> times the maximum eigenvalue are
replaced by <code class="docutils literal notranslate"><span class="pre">svdcut</span></code> times the maximum eigenvalue. This makes
the correlation matrix less singular and less susceptible to
roundoff error. When <code class="docutils literal notranslate"><span class="pre">svdcut</span> <span class="pre">&lt;</span> <span class="pre">0</span></code>, eigenvalues smaller than
<code class="docutils literal notranslate"><span class="pre">|svdcut|</span></code> times the maximum eigenvalue are discarded and the
corresponding components in <code class="docutils literal notranslate"><span class="pre">y</span></code> and <code class="docutils literal notranslate"><span class="pre">prior</span></code> are zeroed out. No
SVD cut is applied if <code class="docutils literal notranslate"><span class="pre">svdcut=None</span></code>. If <code class="docutils literal notranslate"><span class="pre">svdcut</span></code> is a
dictionary, its arguments are passed as keyword arguments to
<code class="docutils literal notranslate"><span class="pre">gvar.svd</span></code>, which is used to apply the  SVD cut: eg,
<code class="docutils literal notranslate"><span class="pre">svdcut=dict(svdcut=1e-4,</span> <span class="pre">add_offsets=True)</span></code>. Default is 1e-12.</li>
<li><strong>add_svdnoise</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">add_svdnoise=True</span></code>, noise is added to
the data means corresponding to the additional uncertainties
introduced when <code class="docutils literal notranslate"><span class="pre">svdcut&gt;0</span></code>. This is useful for testing the
quality of a fit (<code class="docutils literal notranslate"><span class="pre">chi2</span></code>) when large SVD cuts are
employed. Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</li>
<li><strong>add_priornoise</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">add_priornoise=True</span></code>, noise is added to
the prior means corresponding to the uncertainties
in the prior. This is useful for testing the
quality of a fit (<code class="docutils literal notranslate"><span class="pre">chi2</span></code>) when broad priors are
employed. Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</li>
<li><strong>udata</strong> (<em>dict</em><em>, </em><em>array</em><em> or </em><em>tuple</em>) – Same as <code class="docutils literal notranslate"><span class="pre">data</span></code> but instructs the fitter to ignore  correlations
between different pieces of data.  This speeds up the  fit,
particularly for large amounts of data, but ignores potentially
valuable information if the data actually are correlated. Only
one of <code class="docutils literal notranslate"><span class="pre">data</span></code> or <code class="docutils literal notranslate"><span class="pre">udata</span></code> should be specified. (Default is
<code class="docutils literal notranslate"><span class="pre">None</span></code>.)</li>
<li><strong>fitter</strong> (<em>str</em><em> or </em><em>None</em>) – Fitter code. Options if GSL is installed
include: <code class="docutils literal notranslate"><span class="pre">'gsl_multifit'</span></code> (default) and <code class="docutils literal notranslate"><span class="pre">'gsl_v1_multifit'</span></code>
(original fitter). Options if <code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy</span></code> is installed include:
<code class="docutils literal notranslate"><span class="pre">'scipy_least_squares'</span></code> (default if GSL not installed).
<code class="docutils literal notranslate"><span class="pre">gsl_multifit</span></code> has many options, providing extensive user
control. <code class="docutils literal notranslate"><span class="pre">scipy_least_squares</span></code> can be used for fits where the
parameters are bounded. (Bounded parameters can also be
implemented, for any of the fitters, using non-Gaussian priors —
see the tutorial.)</li>
<li><strong>tol</strong> (<em>float</em><em> or </em><em>tuple</em>) – <p>Assigning <code class="docutils literal notranslate"><span class="pre">tol=(xtol,</span> <span class="pre">gtol,</span> <span class="pre">ftol)</span></code> causes the
fit to stop searching for a minimum when any of</p>
<blockquote>
<div><ol class="arabic">
<li><code class="docutils literal notranslate"><span class="pre">xtol</span> <span class="pre">&gt;=</span></code> relative change in parameters between iterations</li>
<li><code class="docutils literal notranslate"><span class="pre">gtol</span> <span class="pre">&gt;=</span></code> relative size of gradient of <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> function</li>
<li><code class="docutils literal notranslate"><span class="pre">ftol</span> <span class="pre">&gt;=</span></code> relative change in <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> between iterations</li>
</ol>
</div></blockquote>
<p>is satisfied. See the fitter documentation for detailed
definitions of these stopping conditions. Typically one sets
<code class="docutils literal notranslate"><span class="pre">xtol=1/10**d</span></code> where <code class="docutils literal notranslate"><span class="pre">d</span></code> is the number of digits of precision
desired in the result, while <code class="docutils literal notranslate"><span class="pre">gtol&lt;&lt;1</span></code> and <code class="docutils literal notranslate"><span class="pre">ftol&lt;&lt;1</span></code>. Setting
<code class="docutils literal notranslate"><span class="pre">tol=eps</span></code> where <code class="docutils literal notranslate"><span class="pre">eps</span></code> is a number is equivalent to setting
<code class="docutils literal notranslate"><span class="pre">tol=(eps,1e-10,1e-10)</span></code>. Setting <code class="docutils literal notranslate"><span class="pre">tol=(eps1,eps2)</span></code> is
equivalent to setting <code class="docutils literal notranslate"><span class="pre">tol=(eps1,eps2,1e-10)</span></code>. Default is
<code class="docutils literal notranslate"><span class="pre">tol=1e-8</span></code>. (Note: the <code class="docutils literal notranslate"><span class="pre">ftol</span></code> option is disabled in some
versions of the GSL library.)</p>
</li>
<li><strong>maxit</strong> (<em>int</em>) – Maximum number of algorithm iterations (or function
evaluations for some fitters) in search for minimum;
default is 1000.</li>
<li><strong>debug</strong> (<em>bool</em>) – Set to <code class="docutils literal notranslate"><span class="pre">True</span></code> for extra debugging of the fit function
and a check for roundoff errors. (Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.)</li>
<li><strong>fitterargs</strong> (<em>dict</em>) – Dictionary of additional arguments passed through
to the underlying fitter. Different fitters offer different
parameters; see the documentation for each.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Objects of type <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> have the following
attributes:</p>
<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.chi2">
<code class="descname">chi2</code><a class="headerlink" href="#lsqfit.nonlinear_fit.chi2" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> – The minimum <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> for the fit.
<code class="docutils literal notranslate"><span class="pre">fit.chi2</span> <span class="pre">/</span> <span class="pre">fit.dof</span></code> is usually of order one in good fits.
Values much less than one suggest that actual fluctuations in
the input data and/or priors might be smaller than suggested
by the standard deviations (or covariances) used in the fit.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.cov">
<code class="descname">cov</code><a class="headerlink" href="#lsqfit.nonlinear_fit.cov" title="Permalink to this definition">¶</a></dt>
<dd><p><em>array</em> – Covariance matrix of the best-fit parameters from
the fit.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.dof">
<code class="descname">dof</code><a class="headerlink" href="#lsqfit.nonlinear_fit.dof" title="Permalink to this definition">¶</a></dt>
<dd><p><em>int</em> – Number of degrees of freedom in the fit, which equals
the number of pieces of data being fit when priors are specified
for the fit parameters. Without priors, it is the number of pieces
of data minus the number of fit parameters.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.error">
<code class="descname">error</code><a class="headerlink" href="#lsqfit.nonlinear_fit.error" title="Permalink to this definition">¶</a></dt>
<dd><p><em>str</em> – Error message generated by the underlying fitter when
an error occurs. <code class="docutils literal notranslate"><span class="pre">None</span></code> otherwise.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.fitter_results">
<code class="descname">fitter_results</code><a class="headerlink" href="#lsqfit.nonlinear_fit.fitter_results" title="Permalink to this definition">¶</a></dt>
<dd><p>Results returned by the underlying fitter. Refer to
the appropriate fitter’s documentation for details.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.logGBF">
<code class="descname">logGBF</code><a class="headerlink" href="#lsqfit.nonlinear_fit.logGBF" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float or None</em> – The logarithm of the probability (density)
of obtaining the fit data by randomly sampling the parameter model
(priors plus fit function) used in the fit — that is, it is
<code class="docutils literal notranslate"><span class="pre">P(data|model)</span></code>. This quantity is useful for comparing fits of
the same data to different models, with different priors and/or
fit functions. The model with the largest value of <code class="docutils literal notranslate"><span class="pre">fit.logGBF</span></code>
is the one preferred by the data. The exponential of the difference
in <code class="docutils literal notranslate"><span class="pre">fit.logGBF</span></code> between two models is the ratio of probabilities
(Bayes factor) for those models. Differences in <code class="docutils literal notranslate"><span class="pre">fit.logGBF</span></code>
smaller than 1 are not very significant. Gaussian statistics are
assumed when computing <code class="docutils literal notranslate"><span class="pre">fit.logGBF</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.p">
<code class="descname">p</code><a class="headerlink" href="#lsqfit.nonlinear_fit.p" title="Permalink to this definition">¶</a></dt>
<dd><p><em>dict, array or gvar.GVar</em> – Best-fit parameters from fit. Depending
upon what was used for the prior (or <code class="docutils literal notranslate"><span class="pre">p0</span></code>), it is either: a
dictionary (<code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.BufferDict</span></code>) of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s and/or arrays of
<code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s; or an array (<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>) of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s.
<code class="docutils literal notranslate"><span class="pre">fit.p</span></code> represents a multi-dimensional Gaussian distribution
which, in Bayesian terminology, is the <em>posterior</em> probability
distribution of the fit parameters.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.pmean">
<code class="descname">pmean</code><a class="headerlink" href="#lsqfit.nonlinear_fit.pmean" title="Permalink to this definition">¶</a></dt>
<dd><p><em>dict, array or float</em> – Means of the best-fit parameters
from fit.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.psdev">
<code class="descname">psdev</code><a class="headerlink" href="#lsqfit.nonlinear_fit.psdev" title="Permalink to this definition">¶</a></dt>
<dd><p><em>dict, array or float</em> – Standard deviations of the best-fit
parameters from fit.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.palt">
<code class="descname">palt</code><a class="headerlink" href="#lsqfit.nonlinear_fit.palt" title="Permalink to this definition">¶</a></dt>
<dd><p><em>dict, array or gvar.GVar</em> – Same as <code class="docutils literal notranslate"><span class="pre">fit.p</span></code> except that the errors
are computed directly from <code class="docutils literal notranslate"><span class="pre">fit.cov</span></code>. This is faster but means
that no information about correlations with the input data is
retained (unlike in <code class="docutils literal notranslate"><span class="pre">fit.p</span></code>); and, therefore, <code class="docutils literal notranslate"><span class="pre">fit.palt</span></code>
cannot be used to generate error budgets. <code class="docutils literal notranslate"><span class="pre">fit.p</span></code> and
<code class="docutils literal notranslate"><span class="pre">fit.palt</span></code> give the same means and normally give the same errors
for each parameter. They differ only when the input data’s
covariance matrix is too singular to invert accurately (because of
roundoff error), in which case an SVD cut is advisable.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.p0">
<code class="descname">p0</code><a class="headerlink" href="#lsqfit.nonlinear_fit.p0" title="Permalink to this definition">¶</a></dt>
<dd><p><em>dict, array or float</em> – The parameter values used to start the fit.
This will differ from the input <code class="docutils literal notranslate"><span class="pre">p0</span></code> if the latter was
incomplete.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.prior">
<code class="descname">prior</code><a class="headerlink" href="#lsqfit.nonlinear_fit.prior" title="Permalink to this definition">¶</a></dt>
<dd><p><em>dict, array, gvar.GVar or None</em> – Prior used in the fit. This may
differ  from the input prior if an SVD cut is used. It is either
a  dictionary (<code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.BufferDict</span></code>) or an array
(<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>), depending upon the input. Equals
<code class="docutils literal notranslate"><span class="pre">None</span></code> if no prior was specified.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.Q">
<code class="descname">Q</code><a class="headerlink" href="#lsqfit.nonlinear_fit.Q" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float or None</em> – The probability that the <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> from the fit
could have been larger, by chance, assuming the best-fit model
is correct. Good fits have <code class="docutils literal notranslate"><span class="pre">Q</span></code> values larger than 0.1 or so.
Also called the <em>p-value</em> of the fit. The probabilistic
intrepretation becomes unreliable if the actual fluctuations
in the input data and/or priors are much smaller than suggested
by the standard deviations (or covariances) used in the fit
(leading to an unusually small <code class="docutils literal notranslate"><span class="pre">chi**2</span></code>).</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.residuals">
<code class="descname">residuals</code><a class="headerlink" href="#lsqfit.nonlinear_fit.residuals" title="Permalink to this definition">¶</a></dt>
<dd><p>An array containing the fit residuals normalized by the
corresponding standard deviations. This includes contributions
from both the fit data and the prior: <code class="docutils literal notranslate"><span class="pre">chi2</span> <span class="pre">=</span> <span class="pre">sum(fit.resid**2)</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.stopping_criterion">
<code class="descname">stopping_criterion</code><a class="headerlink" href="#lsqfit.nonlinear_fit.stopping_criterion" title="Permalink to this definition">¶</a></dt>
<dd><p><em>int</em> – Criterion used to
stop fit:</p>
<blockquote>
<div><p>0: didn’t converge</p>
<p>1: <code class="docutils literal notranslate"><span class="pre">xtol</span> <span class="pre">&gt;=</span></code> relative change in parameters between iterations</p>
<p>2: <code class="docutils literal notranslate"><span class="pre">gtol</span> <span class="pre">&gt;=</span></code> relative size of gradient of <code class="docutils literal notranslate"><span class="pre">chi**2</span></code></p>
<p>3: <code class="docutils literal notranslate"><span class="pre">ftol</span> <span class="pre">&gt;=</span></code> relative change in <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> between iterations</p>
</div></blockquote>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.svdcorrection">
<code class="descname">svdcorrection</code><a class="headerlink" href="#lsqfit.nonlinear_fit.svdcorrection" title="Permalink to this definition">¶</a></dt>
<dd><p><em>gvar.GVar</em> – Sum of all SVD corrections, if any, added
to the fit data <code class="docutils literal notranslate"><span class="pre">y</span></code> or the prior <code class="docutils literal notranslate"><span class="pre">prior</span></code>.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.svdn">
<code class="descname">svdn</code><a class="headerlink" href="#lsqfit.nonlinear_fit.svdn" title="Permalink to this definition">¶</a></dt>
<dd><p><em>int</em> – Number of eigenmodes modified (and/or deleted) by the
SVD cut.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.time">
<code class="descname">time</code><a class="headerlink" href="#lsqfit.nonlinear_fit.time" title="Permalink to this definition">¶</a></dt>
<dd><p><em>float</em> – <em>CPU</em> time (in secs) taken by fit.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.tol">
<code class="descname">tol</code><a class="headerlink" href="#lsqfit.nonlinear_fit.tol" title="Permalink to this definition">¶</a></dt>
<dd><p><em>tuple</em> – Tolerance used in fit. This differs from the input
tolerance if the latter was incompletely specified.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.x">
<code class="descname">x</code><a class="headerlink" href="#lsqfit.nonlinear_fit.x" title="Permalink to this definition">¶</a></dt>
<dd><p><em>obj</em> – The first field in the input <code class="docutils literal notranslate"><span class="pre">data</span></code>. This is sometimes the
independent variable (as in ‘y vs x’ plot), but may be anything.
It is set equal to <code class="docutils literal notranslate"><span class="pre">False</span></code> if the <code class="docutils literal notranslate"><span class="pre">x</span></code> field is omitted from
the input <code class="docutils literal notranslate"><span class="pre">data</span></code>. (This also means that the fit function has no
<code class="docutils literal notranslate"><span class="pre">x</span></code> argument: so <code class="docutils literal notranslate"><span class="pre">f(p)</span></code> rather than <code class="docutils literal notranslate"><span class="pre">f(x,p)</span></code>.)</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.y">
<code class="descname">y</code><a class="headerlink" href="#lsqfit.nonlinear_fit.y" title="Permalink to this definition">¶</a></dt>
<dd><p><em>dict, array or gvar.GVar</em> – Fit data used in the fit. This may differ
from the input data if an SVD cut is used. It is either a
dictionary (<code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.BufferDict</span></code>) or an array
(<code class="xref py py-class docutils literal notranslate"><span class="pre">numpy.ndarray</span></code>), depending upon the input.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.nonlinear_fit.nblocks">
<code class="descname">nblocks</code><a class="headerlink" href="#lsqfit.nonlinear_fit.nblocks" title="Permalink to this definition">¶</a></dt>
<dd><p><em>dict</em> – <code class="docutils literal notranslate"><span class="pre">nblocks[s]</span></code> equals the number of block-diagonal
sub-matrices of the <code class="docutils literal notranslate"><span class="pre">y</span></code>–<code class="docutils literal notranslate"><span class="pre">prior</span></code> covariance matrix that are
size <code class="docutils literal notranslate"><span class="pre">s</span></code>-by-<code class="docutils literal notranslate"><span class="pre">s</span></code>. This is sometimes useful for debugging.</p>
</dd></dl>

<p>The global defaults used by <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> can be changed by
changing entries in dictionary <code class="docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit.DEFAULTS</span></code>
for keys <code class="docutils literal notranslate"><span class="pre">'svdcut'</span></code>, <code class="docutils literal notranslate"><span class="pre">'debug'</span></code>, <code class="docutils literal notranslate"><span class="pre">'tol'</span></code>, <code class="docutils literal notranslate"><span class="pre">'maxit'</span></code>, and
<code class="docutils literal notranslate"><span class="pre">'fitter'</span></code>. Additional defaults can be added to that dictionary
to be are passed through <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> to the underlying
fitter (via dictionary <code class="docutils literal notranslate"><span class="pre">fitterargs</span></code>).</p>
<p>Additional methods are provided for printing out detailed information
about the fit, testing fits with simulated data,
doing bootstrap analyses of the fit errors,
dumping (for later use) and loading parameter values, and checking for roundoff
errors in the final error  estimates:</p>
<dl class="method">
<dt id="lsqfit.nonlinear_fit.format">
<code class="descname">format</code><span class="sig-paren">(</span><em>maxline=0</em>, <em>pstyle='v'</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.format" title="Permalink to this definition">¶</a></dt>
<dd><p>Formats fit output details into a string for printing.</p>
<p>The output tabulates the <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> per degree of freedom of the fit
(<code class="docutils literal notranslate"><span class="pre">chi2/dof</span></code>), the number of degrees of freedom, the <code class="docutils literal notranslate"><span class="pre">Q</span></code>  value of
the fit (ie, p-value), and the logarithm of the Gaussian Bayes Factor
for the fit (<code class="docutils literal notranslate"><span class="pre">logGBF</span></code>). At the end it lists the SVD cut, the number
of eigenmodes modified by the SVD cut, the tolerances used in the fit,
and the time in seconds needed to do the fit. The tolerance used to
terminate the fit is marked with an asterisk. It also lists
information about the fitter used if it is other than the standard
choice.</p>
<p>Optionally, <code class="docutils literal notranslate"><span class="pre">format</span></code> will also list the best-fit values
for the fit parameters together with the prior for each (in <code class="docutils literal notranslate"><span class="pre">[]</span></code> on
each line). Lines for parameters that deviate from their prior by more
than one (prior) standard deviation are marked with asterisks, with
the number of asterisks equal to the number of standard deviations (up
to five). Lines for parameters designated as linear (see <code class="docutils literal notranslate"><span class="pre">linear</span></code>
keyword) are marked with a minus sign after their prior.</p>
<p><code class="docutils literal notranslate"><span class="pre">format</span></code> can also list all of the data and the corresponding values
from the fit, again with asterisks on lines  where there is a
significant discrepancy.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>maxline</strong> (<em>int</em><em> or </em><em>bool</em>) – Maximum number of data points for which
fit results and input data are tabulated. <code class="docutils literal notranslate"><span class="pre">maxline&lt;0</span></code>
implies that only <code class="docutils literal notranslate"><span class="pre">chi2</span></code>, <code class="docutils literal notranslate"><span class="pre">Q</span></code>, <code class="docutils literal notranslate"><span class="pre">logGBF</span></code>, and <code class="docutils literal notranslate"><span class="pre">itns</span></code>
are tabulated; no parameter values are included. Setting
<code class="docutils literal notranslate"><span class="pre">maxline=True</span></code> prints all data points; setting it
equal <code class="docutils literal notranslate"><span class="pre">None</span></code> or <code class="docutils literal notranslate"><span class="pre">False</span></code> is the same as setting
it equal to <code class="docutils literal notranslate"><span class="pre">-1</span></code>. Default is <code class="docutils literal notranslate"><span class="pre">maxline=0</span></code>.</li>
<li><strong>pstyle</strong> (<em>str</em><em> or </em><em>None</em>) – Style used for parameter list. Supported
values are ‘vv’ for very verbose, ‘v’ for verbose, and ‘m’ for
minimal. When ‘m’ is set, only parameters whose values differ
from their prior values are listed. Setting <code class="docutils literal notranslate"><span class="pre">pstyle=None</span></code>
implies no parameters are listed.</li>
<li><strong>extend</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, extend the parameter list to
include values derived from log-normal or other
non-Gaussian parameters. So values for fit parameter
<code class="docutils literal notranslate"><span class="pre">p['log(a)']</span></code>, for example, are listed together with
values <code class="docutils literal notranslate"><span class="pre">p['a']</span></code> for the exponential of the fit parameter.
Setting <code class="docutils literal notranslate"><span class="pre">extend=False</span></code> means that only the value
for <code class="docutils literal notranslate"><span class="pre">p['log(a)']</span></code> is listed. Default is <code class="docutils literal notranslate"><span class="pre">True</span></code>.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">String containing detailed information about fit.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lsqfit.nonlinear_fit.simulated_fit_iter">
<code class="descname">simulated_fit_iter</code><span class="sig-paren">(</span><em>n=None</em>, <em>pexact=None</em>, <em>add_priornoise=False</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.simulated_fit_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator that returns simulation copies of a fit.</p>
<p>Fit reliability is tested using simulated data which
replaces the mean values in <code class="docutils literal notranslate"><span class="pre">self.y</span></code> with random numbers
drawn from a distribution whose mean equals <code class="docutils literal notranslate"><span class="pre">self.fcn(pexact)</span></code>
and whose covariance matrix is the same as <code class="docutils literal notranslate"><span class="pre">self.y</span></code>’s. Simulated
data is very similar to the original fit data, <code class="docutils literal notranslate"><span class="pre">self.y</span></code>,
but corresponds to a world where the correct values for
the parameters (<em>i.e.</em>, averaged over many simulated data
sets) are given by <code class="docutils literal notranslate"><span class="pre">pexact</span></code>. <code class="docutils literal notranslate"><span class="pre">pexact</span></code> is usually taken
equal to <code class="docutils literal notranslate"><span class="pre">fit.pmean</span></code>.</p>
<p>Each iteration of the iterator creates new simulated data,
with different random numbers, and fits it, returning the
the <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> that results. The simulated
data has the same covariance matrix as <code class="docutils literal notranslate"><span class="pre">fit.y</span></code>.
Typical usage is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">...</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">nonlinear_fit</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">for</span> <span class="n">sfit</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">simulated_fit_iter</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">3</span><span class="p">):</span>
    <span class="o">...</span> <span class="n">verify</span> <span class="n">that</span> <span class="n">sfit</span> <span class="n">has</span> <span class="n">a</span> <span class="n">good</span> <span class="n">chi</span><span class="o">**</span><span class="mi">2</span> <span class="o">...</span>
    <span class="o">...</span> <span class="n">verify</span> <span class="n">that</span> <span class="n">sfit</span><span class="o">.</span><span class="n">p</span> <span class="n">agrees</span> <span class="k">with</span> <span class="n">pexact</span><span class="o">=</span><span class="n">fit</span><span class="o">.</span><span class="n">pmean</span> <span class="n">within</span> <span class="n">errors</span> <span class="o">...</span>
</pre></div>
</div>
<p>Only a few iterations are needed to get a sense of the fit’s
reliability since we know the correct answer in each case. The
simulated fit’s output results should agree with <code class="docutils literal notranslate"><span class="pre">pexact</span></code>
(<code class="docutils literal notranslate"><span class="pre">=fit.pmean</span></code> here) within the simulated fit’s errors.</p>
<p>Setting parameter <code class="docutils literal notranslate"><span class="pre">add_priornoise=True</span></code> varies the means of the
priors as well as the means of the data. This option is useful
for testing goodness of fit because with it <code class="docutils literal notranslate"><span class="pre">chi**2/N</span></code> should
be <code class="docutils literal notranslate"><span class="pre">1</span> <span class="pre">±</span> <span class="pre">sqrt(2/N)</span></code>, where <code class="docutils literal notranslate"><span class="pre">N</span></code> is the
number of degrees of freedom. (<code class="docutils literal notranslate"><span class="pre">chi**2/N</span></code> can be significantly
smaller than one without added noise in prior means.)</p>
<p>Simulated fits can also be used to estimate biases in the fit’s
output parameters or functions of them, should non-Gaussian behavior
arise. This is possible, again, because we know the correct value for
every parameter before we do the fit. Again only a few iterations
may be needed for reliable estimates.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n</strong> (int or <code class="docutils literal notranslate"><span class="pre">None</span></code>) – Maximum number of iterations (equals
infinity if <code class="docutils literal notranslate"><span class="pre">None</span></code>).</li>
<li><strong>pexact</strong> (<code class="docutils literal notranslate"><span class="pre">None</span></code> or array/dict of numbers) – Fit-parameter values
for the underlying distribution used to generate simulated
data; replaced by <code class="docutils literal notranslate"><span class="pre">self.pmean</span></code> if is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default).</li>
<li><strong>add_priornoise</strong> (<em>bool</em>) – Vary prior means if <code class="docutils literal notranslate"><span class="pre">True</span></code>;
otherwise vary only the means in <code class="docutils literal notranslate"><span class="pre">self.y</span></code> (default).</li>
<li><strong>kargs</strong> – Dictionary containing override values for fit parameters.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator that returns <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a>s
for different simulated data.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lsqfit.nonlinear_fit.simulated_data_iter">
<code class="descname">simulated_data_iter</code><span class="sig-paren">(</span><em>n=None</em>, <em>pexact=None</em>, <em>add_priornoise=False</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.simulated_data_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator that returns simulated data based upon a fit’s data.</p>
<p>Simulated data is generated from a fit’s data <code class="docutils literal notranslate"><span class="pre">fit.y</span></code> by
replacing the mean values in that data with random numbers
drawn from a distribution whose mean is <code class="docutils literal notranslate"><span class="pre">self.fcn(pexact)</span></code>
and whose covariance matrix is the same as that of <code class="docutils literal notranslate"><span class="pre">self.y</span></code>.
Each iteration of the iterator returns new simulated data,
with different random numbers for the means and a covariance
matrix equal to that of <code class="docutils literal notranslate"><span class="pre">self.y</span></code>. This iterator is used by
<code class="docutils literal notranslate"><span class="pre">self.simulated_fit_iter</span></code>.</p>
<p>Typical usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fit</span> <span class="o">=</span> <span class="n">nonlinear_fit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">fcn</span><span class="o">=</span><span class="n">fcn</span><span class="p">)</span>
<span class="o">...</span>
<span class="k">for</span> <span class="n">ysim</span><span class="p">,</span> <span class="n">priorsim</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">simulate_data_iter</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="n">fitsim</span> <span class="o">=</span> <span class="n">nonlinear_fit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">ysim</span><span class="p">),</span> <span class="n">prior</span><span class="o">=</span><span class="n">priorsim</span><span class="p">,</span> <span class="n">fcn</span><span class="o">=</span><span class="n">fcn</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">fitsim</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;chi2 =&#39;</span><span class="p">,</span> <span class="n">gv</span><span class="o">.</span><span class="n">chi2</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">fitsim</span><span class="o">.</span><span class="n">p</span><span class="p">))</span>
</pre></div>
</div>
<p>This code tests the fitting protocol on simulated data, comparing the
best fit parameters in each case with the correct values (<code class="docutils literal notranslate"><span class="pre">fit.p</span></code>).
The loop in this code is functionally the same as (but probably not
as fast as):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">for</span> <span class="n">fitsim</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">simulated_fit_iter</span><span class="p">(</span><span class="n">n</span><span class="o">=</span><span class="mi">10</span><span class="p">):</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">fitsim</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="s1">&#39;chi2 =&#39;</span><span class="p">,</span> <span class="n">gv</span><span class="o">.</span><span class="n">chi2</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">,</span> <span class="n">fitsim</span><span class="o">.</span><span class="n">p</span><span class="p">))</span>
</pre></div>
</div>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n</strong> (<em>int</em><em> or </em><em>None</em>) – Maximum number of iterations (equals
infinity if <code class="docutils literal notranslate"><span class="pre">None</span></code>).</li>
<li><strong>pexact</strong> (<em>None</em><em> or </em><em>dict/array of numbers</em>) – Fit-parameter values for
the underlying distribution used to generate simulated data;
replaced by <code class="docutils literal notranslate"><span class="pre">self.pmean</span></code> if is <code class="docutils literal notranslate"><span class="pre">None</span></code> (default).</li>
<li><strong>add_priornoise</strong> (<em>bool</em>) – Vary prior means if <code class="docutils literal notranslate"><span class="pre">True</span></code>; otherwise
vary only the means in <code class="docutils literal notranslate"><span class="pre">self.y</span></code> (default).</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">An iterator that returns a 2-tuple containing simulated
versions of self.y and self.prior: <code class="docutils literal notranslate"><span class="pre">(ysim,</span> <span class="pre">priorsim)</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lsqfit.nonlinear_fit.bootstrapped_fit_iter">
<code class="descname">bootstrapped_fit_iter</code><span class="sig-paren">(</span><em>n=None</em>, <em>datalist=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.bootstrapped_fit_iter" title="Permalink to this definition">¶</a></dt>
<dd><p>Iterator that returns bootstrap copies of a fit.</p>
<p>A bootstrap analysis involves three steps: 1) make a large number
of “bootstrap copies” of the original input data and prior that differ
from each other by random amounts characteristic of the underlying
randomness in the original data; 2) repeat the entire fit analysis
for each bootstrap copy of the data, extracting fit results from
each; and 3) use the variation of the fit results from bootstrap
copy to bootstrap copy to determine an approximate probability
distribution (possibly non-gaussian) for the fit parameters and/or
functions of them: the results from each bootstrap fit are samples
from that distribution.</p>
<p>Bootstrap copies of the data for step 2 are provided in
<code class="docutils literal notranslate"><span class="pre">datalist</span></code>. If <code class="docutils literal notranslate"><span class="pre">datalist</span></code> is <code class="docutils literal notranslate"><span class="pre">None</span></code>, they are generated
instead from the means and covariance matrix of the fit data
(assuming gaussian statistics). The maximum number of bootstrap
copies considered is specified by <code class="docutils literal notranslate"><span class="pre">n</span></code> (<code class="docutils literal notranslate"><span class="pre">None</span></code> implies no
limit).</p>
<p>Variations in the best-fit parameters (or functions of them)
from bootstrap fit to bootstrap fit define the probability
distributions for those quantities. For example, one could use the
following code to analyze the distribution of function <code class="docutils literal notranslate"><span class="pre">g(p)</span></code>
of the fit parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fit</span> <span class="o">=</span> <span class="n">nonlinear_fit</span><span class="p">(</span><span class="o">...</span><span class="p">)</span>

<span class="o">...</span>

<span class="n">glist</span> <span class="o">=</span> <span class="p">[]</span>
<span class="k">for</span> <span class="n">bsfit</span> <span class="ow">in</span> <span class="n">fit</span><span class="o">.</span><span class="n">bootstrapped_fit_iter</span><span class="p">(</span>
    <span class="n">n</span><span class="o">=</span><span class="mi">100</span><span class="p">,</span> <span class="n">datalist</span><span class="o">=</span><span class="n">datalist</span><span class="p">,</span>
    <span class="p">):</span>
    <span class="n">glist</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">g</span><span class="p">(</span><span class="n">bsfit</span><span class="o">.</span><span class="n">pmean</span><span class="p">))</span>

<span class="o">...</span> <span class="n">analyze</span> <span class="n">samples</span> <span class="n">glist</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="kn">from</span> <span class="nn">g</span><span class="p">(</span><span class="n">p</span><span class="p">)</span> <span class="n">distribution</span> <span class="o">...</span>
</pre></div>
</div>
<p>This code generates <code class="docutils literal notranslate"><span class="pre">n=100</span></code> samples <code class="docutils literal notranslate"><span class="pre">glist[i]</span></code> from the
probability distribution of <code class="docutils literal notranslate"><span class="pre">g(p)</span></code>. If everything is Gaussian,
the mean and standard deviation of <code class="docutils literal notranslate"><span class="pre">glist[i]</span></code> should agree
with <code class="docutils literal notranslate"><span class="pre">g(fit.p).mean</span></code> and <code class="docutils literal notranslate"><span class="pre">g(fit.p).sdev</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>n</strong> (<em>int</em>) – Maximum number of iterations if <code class="docutils literal notranslate"><span class="pre">n</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>;
otherwise there is no maximum.</li>
<li><strong>datalist</strong> (<em>iter</em>) – Collection of bootstrap <code class="docutils literal notranslate"><span class="pre">data</span></code> sets for fitter.</li>
<li><strong>kargs</strong> (<em>dict</em>) – Overrides arguments in original fit.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">Iterator that returns an <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> object
containing results from the fit to the next data set in
<code class="docutils literal notranslate"><span class="pre">datalist</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lsqfit.nonlinear_fit.check_roundoff">
<code class="descname">check_roundoff</code><span class="sig-paren">(</span><em>rtol=0.25</em>, <em>atol=1e-6</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.check_roundoff" title="Permalink to this definition">¶</a></dt>
<dd><p>Check for roundoff errors in fit.p.</p>
<p>Compares standard deviations from fit.p and fit.palt to see if they
agree to within relative tolerance <code class="docutils literal notranslate"><span class="pre">rtol</span></code> and absolute tolerance
<code class="docutils literal notranslate"><span class="pre">atol</span></code>. Generates a warning if they do not (in which
case an SVD cut might be advisable).</p>
</dd></dl>

<dl class="staticmethod">
<dt id="lsqfit.nonlinear_fit.set">
<em class="property">static </em><code class="descname">set</code><span class="sig-paren">(</span><em>clear=False</em>, <em>**defaults</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.nonlinear_fit.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Set default parameters for <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a>.</p>
<p>Use to set default values for parameters: <code class="docutils literal notranslate"><span class="pre">svdcut</span></code>,
<code class="docutils literal notranslate"><span class="pre">debug</span></code>, <code class="docutils literal notranslate"><span class="pre">tol</span></code>, <code class="docutils literal notranslate"><span class="pre">maxit</span></code>, and <code class="docutils literal notranslate"><span class="pre">fitter</span></code>. Can also set
parameters specific to the fitter specified by the <code class="docutils literal notranslate"><span class="pre">fitter</span></code>
argument.</p>
<p>Sample usage:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">lsqfit</span>

<span class="n">old_defaults</span> <span class="o">=</span> <span class="n">lsqfit</span><span class="o">.</span><span class="n">nonlinear_fit</span><span class="o">.</span><span class="n">set</span><span class="p">(</span>
    <span class="n">fitter</span><span class="o">=</span><span class="s1">&#39;gsl_multifit&#39;</span><span class="p">,</span> <span class="n">alg</span><span class="o">=</span><span class="s1">&#39;subspace2D&#39;</span><span class="p">,</span> <span class="n">solver</span><span class="o">=</span><span class="s1">&#39;cholesky&#39;</span><span class="p">,</span>
    <span class="n">tol</span><span class="o">=</span><span class="mf">1e-10</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">,</span>
    <span class="p">)</span>
</pre></div>
</div>
<p><code class="docutils literal notranslate"><span class="pre">nonlinear_fit.set()</span></code> without arguments returns a
dictionary containing the current defaults.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>clear</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> remove earlier settings,
restoring the original defaults, before adding new
defaults. The default value is <code class="docutils literal notranslate"><span class="pre">clear=False</span></code>.
<code class="docutils literal notranslate"><span class="pre">nonlinear_fit.set(clear=True)</span></code> restores the
original defaults.</li>
<li><strong>defaults</strong> (<em>dict</em>) – Dictionary containing new defaults.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A dictionary containing the old defaults,
before they were updated. These can be restored using
<code class="docutils literal notranslate"><span class="pre">nonlinear_fit.set(old_defaults)</span></code> where <code class="docutils literal notranslate"><span class="pre">old_defaults</span></code>
is the dictionary containint the old defaults.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="functions">
<h2>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h2>
<dl class="function">
<dt id="lsqfit.empbayes_fit">
<code class="descclassname">lsqfit.</code><code class="descname">empbayes_fit</code><span class="sig-paren">(</span><em>z0</em>, <em>fitargs</em>, <em>**minargs</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.empbayes_fit" title="Permalink to this definition">¶</a></dt>
<dd><p>Return fit and <code class="docutils literal notranslate"><span class="pre">z</span></code> corresponding to the fit
<code class="docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit(**fitargs(z))</span></code> that maximizes <code class="docutils literal notranslate"><span class="pre">logGBF</span></code>.</p>
<p>This function maximizes the logarithm of the Bayes Factor from
fit  <code class="docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit(**fitargs(z))</span></code> by varying <code class="docutils literal notranslate"><span class="pre">z</span></code>,
starting at <code class="docutils literal notranslate"><span class="pre">z0</span></code>. The fit is redone for each value of <code class="docutils literal notranslate"><span class="pre">z</span></code>
that is tried, in order to determine <code class="docutils literal notranslate"><span class="pre">logGBF</span></code>.</p>
<p>The Bayes Factor is proportional to the probability that the data
came from the model (fit function and priors) used in the fit.
<a class="reference internal" href="#lsqfit.empbayes_fit" title="lsqfit.empbayes_fit"><code class="xref py py-func docutils literal notranslate"><span class="pre">empbayes_fit()</span></code></a> finds the model or data that maximizes this
probability.</p>
<p>One application is illustrated by the following code:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">lsqfit</span>

<span class="c1"># fit data</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">1.</span><span class="p">,</span> <span class="mf">2.</span><span class="p">,</span> <span class="mf">3.</span><span class="p">,</span> <span class="mf">4.</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">3.4422</span><span class="p">,</span> <span class="mf">1.2929</span><span class="p">,</span> <span class="mf">0.4798</span><span class="p">,</span> <span class="mf">0.1725</span><span class="p">])</span>

<span class="c1"># prior</span>
<span class="n">prior</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">([</span><span class="s1">&#39;10(1)&#39;</span><span class="p">,</span> <span class="s1">&#39;1.0(1)&#39;</span><span class="p">])</span>

<span class="c1"># fit function</span>
<span class="k">def</span> <span class="nf">fcn</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">*</span> <span class="n">gv</span><span class="o">.</span><span class="n">exp</span><span class="p">(</span> <span class="o">-</span> <span class="n">p</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span><span class="p">)</span>

<span class="c1"># find optimal dy</span>
<span class="k">def</span> <span class="nf">fitargs</span><span class="p">(</span><span class="n">z</span><span class="p">):</span>
    <span class="n">dy</span> <span class="o">=</span> <span class="n">y</span> <span class="o">*</span> <span class="n">z</span>
    <span class="n">newy</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="n">y</span><span class="p">,</span> <span class="n">dy</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">dict</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">newy</span><span class="p">),</span> <span class="n">fcn</span><span class="o">=</span><span class="n">fcn</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">)</span>

<span class="n">fit</span><span class="p">,</span> <span class="n">z</span> <span class="o">=</span> <span class="n">lsqfit</span><span class="o">.</span><span class="n">empbayes_fit</span><span class="p">(</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">fitargs</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">format</span><span class="p">(</span><span class="kc">True</span><span class="p">))</span>
</pre></div>
</div>
<p>Here we want to fit data <code class="docutils literal notranslate"><span class="pre">y</span></code> with fit function <code class="docutils literal notranslate"><span class="pre">fcn</span></code> but we don’t know
the uncertainties in our <code class="docutils literal notranslate"><span class="pre">y</span></code> values. We assume that the relative errors
are <code class="docutils literal notranslate"><span class="pre">x</span></code>-independent and uncorrelated. We add the error <code class="docutils literal notranslate"><span class="pre">dy</span></code> that
maximizes the Bayes Factor, as this is the most likely choice. This fit
gives the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Least</span> <span class="n">Square</span> <span class="n">Fit</span><span class="p">:</span>
  <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span> <span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.58</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.67</span>    <span class="n">logGBF</span> <span class="o">=</span> <span class="mf">7.4834</span>

<span class="n">Parameters</span><span class="p">:</span>
              <span class="mi">0</span>     <span class="mf">9.44</span> <span class="p">(</span><span class="mi">18</span><span class="p">)</span>     <span class="p">[</span> <span class="mf">10.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>
              <span class="mi">1</span>   <span class="mf">0.9979</span> <span class="p">(</span><span class="mi">69</span><span class="p">)</span>     <span class="p">[</span>  <span class="mf">1.00</span> <span class="p">(</span><span class="mi">10</span><span class="p">)</span> <span class="p">]</span>

<span class="n">Fit</span><span class="p">:</span>
     <span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>           <span class="n">y</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>      <span class="n">f</span><span class="p">(</span><span class="n">x</span><span class="p">[</span><span class="n">k</span><span class="p">],</span><span class="n">p</span><span class="p">)</span>
<span class="o">---------------------------------------</span>
        <span class="mi">1</span>     <span class="mf">3.442</span> <span class="p">(</span><span class="mi">54</span><span class="p">)</span>     <span class="mf">3.481</span> <span class="p">(</span><span class="mi">45</span><span class="p">)</span>
        <span class="mi">2</span>     <span class="mf">1.293</span> <span class="p">(</span><span class="mi">20</span><span class="p">)</span>     <span class="mf">1.283</span> <span class="p">(</span><span class="mi">11</span><span class="p">)</span>
        <span class="mi">3</span>    <span class="mf">0.4798</span> <span class="p">(</span><span class="mi">75</span><span class="p">)</span>    <span class="mf">0.4731</span> <span class="p">(</span><span class="mi">41</span><span class="p">)</span>
        <span class="mi">4</span>    <span class="mf">0.1725</span> <span class="p">(</span><span class="mi">27</span><span class="p">)</span>    <span class="mf">0.1744</span> <span class="p">(</span><span class="mi">23</span><span class="p">)</span>

<span class="n">Settings</span><span class="p">:</span>
  <span class="n">svdcut</span><span class="o">/</span><span class="n">n</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="o">/</span><span class="mi">0</span>    <span class="n">tol</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e-08</span><span class="o">*</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">)</span>    <span class="p">(</span><span class="n">itns</span><span class="o">/</span><span class="n">time</span> <span class="o">=</span> <span class="mi">3</span><span class="o">/</span><span class="mf">0.0</span><span class="p">)</span>
</pre></div>
</div>
<p>We have, in effect, used the variation in the data relative to the best
fit curve to estimate that the uncertainty in each data point is
of order 1.6%.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>z0</strong> (<em>number</em><em>, </em><em>array</em><em> or </em><em>dict</em>) – Starting point for search.</li>
<li><strong>fitargs</strong> (<em>callable</em>) – Function of <code class="docutils literal notranslate"><span class="pre">z</span></code> that returns a
dictionary <code class="docutils literal notranslate"><span class="pre">args</span></code> containing the <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a>
arguments corresponding to <code class="docutils literal notranslate"><span class="pre">z</span></code>. <code class="docutils literal notranslate"><span class="pre">z</span></code> should have
the same layout (number, array or dictionary) as <code class="docutils literal notranslate"><span class="pre">z0</span></code>.
<code class="docutils literal notranslate"><span class="pre">fitargs(z)</span></code> can instead return a tuple <code class="docutils literal notranslate"><span class="pre">(args,</span> <span class="pre">plausibility)</span></code>,
where <code class="docutils literal notranslate"><span class="pre">args</span></code> is again the dictionary for
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a>. <code class="docutils literal notranslate"><span class="pre">plausibility</span></code> is the logarithm
of the <em>a priori</em> probabilitiy that <code class="docutils literal notranslate"><span class="pre">z</span></code> is sensible. When
<code class="docutils literal notranslate"><span class="pre">plausibility</span></code> is provided, <a class="reference internal" href="#lsqfit.empbayes_fit" title="lsqfit.empbayes_fit"><code class="xref py py-func docutils literal notranslate"><span class="pre">lsqfit.empbayes_fit()</span></code></a>
maximizes the sum <code class="docutils literal notranslate"><span class="pre">logGBF</span> <span class="pre">+</span> <span class="pre">plausibility</span></code>. Specifying
<code class="docutils literal notranslate"><span class="pre">plausibility</span></code> is a way of steering selections away from
completely implausible values for <code class="docutils literal notranslate"><span class="pre">z</span></code>.</li>
<li><strong>minargs</strong> (<em>dict</em>) – Optional argument dictionary, passed on to
<a class="reference internal" href="gsl.html#lsqfit.gsl_multiminex" title="lsqfit.gsl_multiminex"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.gsl_multiminex</span></code></a> (or
<a class="reference internal" href="scipy.html#lsqfit.scipy_multiminex" title="lsqfit.scipy_multiminex"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.scipy_multiminex</span></code></a>), which finds the minimum.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last">A tuple containing the best fit (object of type
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a>) and the
optimal value for parameter <code class="docutils literal notranslate"><span class="pre">z</span></code>.</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="lsqfit.wavg">
<code class="descclassname">lsqfit.</code><code class="descname">wavg</code><span class="sig-paren">(</span><em>datalist</em>, <em>fast=False</em>, <em>prior=None</em>, <em>**fitterargs</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.wavg" title="Permalink to this definition">¶</a></dt>
<dd><p>Weighted average of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s or arrays/dicts of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s.</p>
<p>The weighted average of <code class="docutils literal notranslate"><span class="pre">N</span></code> <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">xavg</span> <span class="o">=</span> <span class="n">wavg</span><span class="p">([</span><span class="n">g1</span><span class="p">,</span> <span class="n">g2</span> <span class="o">...</span> <span class="n">gN</span><span class="p">])</span>
</pre></div>
</div>
<p>is what one obtains from a weighted least-squares fit of the
collection of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s to the one-parameter fit function</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">N</span> <span class="o">*</span> <span class="p">[</span><span class="n">p</span><span class="p">]</span>
</pre></div>
</div>
<p>The average is the best-fit value for fit parameter <code class="docutils literal notranslate"><span class="pre">p</span></code>.  <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s
with smaller standard deviations carry more weight than those with
larger standard deviations; and the averages take account of
correlations between the <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s.</p>
<p><code class="docutils literal notranslate"><span class="pre">wavg</span></code> also works when each <code class="docutils literal notranslate"><span class="pre">gi</span></code> is an array of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s or a
dictionary whose values are <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s or arrays of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s.
Corresponding arrays in different <code class="docutils literal notranslate"><span class="pre">gi</span></code>s must have the same dimension,
but can have different shapes (the overlapping components are
averaged).  When the <code class="docutils literal notranslate"><span class="pre">gi</span></code> are dictionaries, they need not all have
the same keys.</p>
<p>Weighted averages can become costly when the number of random samples
being averaged is large (100s or more). In such cases it might be useful
to set parameter <code class="docutils literal notranslate"><span class="pre">fast=True</span></code>. This causes <code class="docutils literal notranslate"><span class="pre">wavg</span></code> to estimate the
weighted average by incorporating the random samples one at a time into a
running average:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">result</span> <span class="o">=</span> <span class="n">datalist</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
<span class="k">for</span> <span class="n">di</span> <span class="ow">in</span> <span class="n">datalist</span><span class="p">[</span><span class="mi">1</span><span class="p">:]:</span>
    <span class="n">result</span> <span class="o">=</span> <span class="n">wavg</span><span class="p">([</span><span class="n">result</span><span class="p">,</span> <span class="n">di</span><span class="p">],</span> <span class="o">...</span><span class="p">)</span>
</pre></div>
</div>
<p>This method can be much faster when <code class="docutils literal notranslate"><span class="pre">len(datalist)</span></code> is large, and gives
the exact result when there are no correlations between different elements
of list <code class="docutils literal notranslate"><span class="pre">datalist</span></code>. The results are approximately correct when
<code class="docutils literal notranslate"><span class="pre">datalist[i]</span></code> and <code class="docutils literal notranslate"><span class="pre">datalist[j]</span></code> are correlated for <code class="docutils literal notranslate"><span class="pre">i!=j</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first simple">
<li><strong>datalist</strong> (<em>list</em>) – The <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s to be averaged. <code class="docutils literal notranslate"><span class="pre">datalist</span></code> is
a one-dimensional sequence of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s, or of arrays of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s,
or of dictionaries containing <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s  and/or arrays of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s.
Corresponding arrays in different <code class="docutils literal notranslate"><span class="pre">datalist[i]</span></code>s must have the
same dimension.</li>
<li><strong>fast</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">fast=True</span></code>, <code class="docutils literal notranslate"><span class="pre">wavg</span></code> averages the <code class="docutils literal notranslate"><span class="pre">datalist[i]</span></code>
sequentially. This can be much faster when averaging a large
number of sampes but is only approximate if the different
elements of <code class="docutils literal notranslate"><span class="pre">datalist</span></code> are correlated. Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</li>
<li><strong>fitterargs</strong> (<em>dict</em>) – Additional arguments (e.g., <code class="docutils literal notranslate"><span class="pre">svdcut</span></code>) for the
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> fitter used to do the averaging.</li>
</ul>
</td>
</tr>
<tr class="field-even field"><th class="field-name">Returns:</th><td class="field-body"><p class="first last"><p>The weighted average is returned as a <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code> or an array of
<code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s or a dictionary of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s and arrays of <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.GVar</span></code>s.
Results have the following extra attributes:</p>
<p><strong>chi2</strong> - <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> for weighted average.</p>
<p><strong>dof</strong> - Effective number of degrees of freedom.</p>
<dl class="docutils">
<dt><strong>Q</strong> - Quality factor <cite>Q</cite> (or <em>p-value</em>) for fit:</dt>
<dd><p class="first last">the probability that the <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> could have been larger,
by chance, assuming that the data are all Gaussian and consistent
with each other. Values smaller than 0.1 or so suggest that the
data are not Gaussian or are inconsistent with each other. Also
called the <em>p-value</em>.</p>
</dd>
</dl>
<p><strong>time</strong> - Time required to do average.</p>
<dl class="docutils">
<dt><strong>svdcorrection</strong> - The <em>svd</em> corrections made to the data</dt>
<dd><p class="first last">when <code class="docutils literal notranslate"><span class="pre">svdcut</span></code> is not <code class="docutils literal notranslate"><span class="pre">None</span></code>.</p>
</dd>
</dl>
<p><strong>fit</strong> - Fit returned by <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a>.</p>
</p>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="function">
<dt id="lsqfit.gammaQ">
<code class="descclassname">lsqfit.</code><code class="descname">gammaQ</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.gammaQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Return the normalized incomplete gamma function <code class="docutils literal notranslate"><span class="pre">Q(a,x)</span> <span class="pre">=</span> <span class="pre">1-P(a,x)</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">Q(a,</span> <span class="pre">x)</span> <span class="pre">=</span> <span class="pre">1/Gamma(a)</span> <span class="pre">*</span> <span class="pre">\int_x^\infty</span> <span class="pre">dt</span> <span class="pre">exp(-t)</span> <span class="pre">t</span> <span class="pre">**</span> <span class="pre">(a-1)</span> <span class="pre">=</span> <span class="pre">1</span> <span class="pre">-</span> <span class="pre">P(a,</span> <span class="pre">x)</span></code></p>
<p>Note that <code class="docutils literal notranslate"><span class="pre">gammaQ(ndof/2.,</span> <span class="pre">chi2/2.)</span></code> is the probabilty that one could
get a <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> larger than <code class="docutils literal notranslate"><span class="pre">chi2</span></code> with <code class="docutils literal notranslate"><span class="pre">ndof</span></code> degrees
of freedom even if the model used to construct <code class="docutils literal notranslate"><span class="pre">chi2</span></code> is correct.</p>
</dd></dl>

</div>
<div class="section" id="classes-for-bayesian-integrals">
<h2>Classes for Bayesian Integrals<a class="headerlink" href="#classes-for-bayesian-integrals" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code></a> provides support for doing Bayesian integrals, using results
from a least-squares fit to optimize the multi-dimensional integral. This
is useful for severely non-Gaussian situations. Module <code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> is
used to do the integrals, using an adaptive Monte Carlo algorithm.</p>
<p>The integrator class is:</p>
<dl class="class">
<dt id="lsqfit.BayesIntegrator">
<em class="property">class </em><code class="descclassname">lsqfit.</code><code class="descname">BayesIntegrator</code><span class="sig-paren">(</span><em>fit</em>, <em>limit=1e15</em>, <em>scale=1</em>, <em>pdf=None</em>, <em>adapt_to_pdf=True</em>, <em>svdcut=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.BayesIntegrator" title="Permalink to this definition">¶</a></dt>
<dd><p><code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> integrator for Bayesian fit integrals.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fit</strong> – Fit from <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">nonlinear_fit</span></code></a>.</li>
<li><strong>limit</strong> (<em>positive float</em>) – Limits the integrations to a finite
region of size <code class="docutils literal notranslate"><span class="pre">limit</span></code> times the standard deviation on
either side of the mean. This can be useful if the
functions being integrated misbehave for large parameter
values (e.g., <code class="docutils literal notranslate"><span class="pre">numpy.exp</span></code> overflows for a large range of
arguments). Default is <code class="docutils literal notranslate"><span class="pre">1e15</span></code>.</li>
<li><strong>scale</strong> (<em>positive float</em>) – The integration variables are
rescaled to emphasize parameter values of order
<code class="docutils literal notranslate"><span class="pre">scale</span></code> times the corresponding standard deviations.
The rescaling does not change the value of the integral but it
can reduce uncertainties in the <code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> estimates.
Default is <code class="docutils literal notranslate"><span class="pre">1.0</span></code>.</li>
<li><strong>pdf</strong> (<em>callable</em>) – Probability density function <code class="docutils literal notranslate"><span class="pre">pdf(p)</span></code> of the
fit parameters to use in place of the normal PDF associated
with the least-squares fit used to create the integrator.</li>
<li><strong>adapt_to_pdf</strong> (<em>bool</em>) – <code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> adapts to the PDF if
<code class="docutils literal notranslate"><span class="pre">True</span></code> (default); otherwise it adapts to <code class="docutils literal notranslate"><span class="pre">f(p)</span></code>
times the PDF.</li>
<li><strong>svdcut</strong> (<em>non-negative float</em><em> or </em><em>None</em>) – If not <code class="docutils literal notranslate"><span class="pre">None</span></code>, replace
covariance matrix of <code class="docutils literal notranslate"><span class="pre">g</span></code> with a new matrix whose
small eigenvalues are modified: eigenvalues smaller than
<code class="docutils literal notranslate"><span class="pre">svdcut</span></code> times the maximum eigenvalue <code class="docutils literal notranslate"><span class="pre">eig_max</span></code> are
replaced by <code class="docutils literal notranslate"><span class="pre">svdcut*eig_max</span></code>. This can ameliorate
problems caused by roundoff errors when inverting the
covariance matrix. It increases the uncertainty associated
with the modified eigenvalues and so is conservative.
Setting <code class="docutils literal notranslate"><span class="pre">svdcut=None</span></code> or <code class="docutils literal notranslate"><span class="pre">svdcut=0</span></code> leaves the
covariance matrix unchanged. Default is <code class="docutils literal notranslate"><span class="pre">1e-12</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">BayesIntegrator(fit)</span></code> is a <code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> integrator that evaluates
expectation values for the multi-dimensional Bayesian distribution
associated with <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">nonlinear_fit</span></code></a> <code class="docutils literal notranslate"><span class="pre">fit</span></code>: the probability
density function is the exponential of the <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> function
(times <code class="docutils literal notranslate"><span class="pre">-1/2</span></code>), for data and priors, used in the fit.
For linear fits, it is equivalent to <code class="docutils literal notranslate"><span class="pre">vegas.PDFIntegrator(fit.p)</span></code>,
since the <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> function is  quadratic in the fit parameters;
but they can differ significantly for nonlinear fits.</p>
<p><code class="docutils literal notranslate"><span class="pre">BayesIntegrator</span></code> integrates over the entire parameter space but
first re-expresses the integrals in terms of variables that
diagonalize the covariance matrix of the best-fit parameters
<code class="docutils literal notranslate"><span class="pre">fit.p</span></code> from <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">nonlinear_fit</span></code></a> and are centered at the
best-fit values. This greatly facilitates the integration using
<code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code>, making integrals over 10s or more of parameters feasible.
(The <code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> module must be installed separately in order
to use <code class="docutils literal notranslate"><span class="pre">BayesIntegrator</span></code>.)</p>
<p>A simple illustration of <code class="docutils literal notranslate"><span class="pre">BayesIntegrator</span></code> is given by the following
code, which we use to evaluate the mean and standard deviation for
<code class="docutils literal notranslate"><span class="pre">s*g</span></code> where <code class="docutils literal notranslate"><span class="pre">s</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> are fit parameters:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">lsqfit</span>
<span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>
<span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>

<span class="c1"># least-squares fit</span>
<span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">([</span><span class="mf">0.1</span><span class="p">,</span> <span class="mf">1.2</span><span class="p">,</span> <span class="mf">1.9</span><span class="p">,</span> <span class="mf">3.5</span><span class="p">])</span>
<span class="n">y</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">([</span><span class="s1">&#39;1.2(1.0)&#39;</span><span class="p">,</span> <span class="s1">&#39;2.4(1)&#39;</span><span class="p">,</span> <span class="s1">&#39;2.0(1.2)&#39;</span><span class="p">,</span> <span class="s1">&#39;5.2(3.2)&#39;</span><span class="p">])</span>
<span class="n">prior</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="s1">&#39;0(5)&#39;</span><span class="p">,</span> <span class="n">s</span><span class="o">=</span><span class="s1">&#39;0(2)&#39;</span><span class="p">,</span> <span class="n">g</span><span class="o">=</span><span class="s1">&#39;2(2)&#39;</span><span class="p">))</span>
<span class="k">def</span> <span class="nf">f</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
    <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">x</span> <span class="o">**</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">]</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">lsqfit</span><span class="o">.</span><span class="n">nonlinear_fit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">),</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">,</span> <span class="n">fcn</span><span class="o">=</span><span class="n">f</span><span class="p">,</span> <span class="n">debug</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>

<span class="c1"># Bayesian integral to evaluate expectation value of s*g</span>
<span class="k">def</span> <span class="nf">g</span><span class="p">(</span><span class="n">p</span><span class="p">):</span>
    <span class="n">sg</span> <span class="o">=</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">p</span><span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">]</span>
    <span class="k">return</span> <span class="p">[</span><span class="n">sg</span><span class="p">,</span> <span class="n">sg</span><span class="o">**</span><span class="mi">2</span><span class="p">]</span>

<span class="n">expval</span> <span class="o">=</span> <span class="n">lsqfit</span><span class="o">.</span><span class="n">BayesIntegrator</span><span class="p">(</span><span class="n">fit</span><span class="p">,</span> <span class="n">limit</span><span class="o">=</span><span class="mf">20.</span><span class="p">)</span>
<span class="n">warmup</span> <span class="o">=</span> <span class="n">expval</span><span class="p">(</span><span class="n">neval</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">10</span><span class="p">)</span>
<span class="n">results</span> <span class="o">=</span> <span class="n">expval</span><span class="p">(</span><span class="n">g</span><span class="p">,</span> <span class="n">neval</span><span class="o">=</span><span class="mi">4000</span><span class="p">,</span> <span class="n">nitn</span><span class="o">=</span><span class="mi">15</span><span class="p">,</span> <span class="n">adapt</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">results</span><span class="o">.</span><span class="n">summary</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;results =&#39;</span><span class="p">,</span> <span class="n">results</span><span class="p">,</span> <span class="s1">&#39;</span><span class="se">\n</span><span class="s1">&#39;</span><span class="p">)</span>
<span class="n">sg</span><span class="p">,</span> <span class="n">sg2</span> <span class="o">=</span> <span class="n">results</span>
<span class="n">sg_sdev</span> <span class="o">=</span> <span class="p">(</span><span class="n">sg2</span> <span class="o">-</span> <span class="n">sg</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span> <span class="o">**</span> <span class="mf">0.5</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;s*g from Bayes integral:  mean =&#39;</span><span class="p">,</span> <span class="n">sg</span><span class="p">,</span> <span class="s1">&#39;  sdev =&#39;</span><span class="p">,</span> <span class="n">sg_sdev</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;s*g from fit:&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;s&#39;</span><span class="p">]</span> <span class="o">*</span> <span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;g&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>where the <code class="docutils literal notranslate"><span class="pre">warmup</span></code> calls to the integrator are used to adapt it to
probability density function from the fit, and then the integrator
is used to evaluate the expectation value of <code class="docutils literal notranslate"><span class="pre">g(p)</span></code>, which is
returned in array <code class="docutils literal notranslate"><span class="pre">results</span></code>.  Here <code class="docutils literal notranslate"><span class="pre">neval</span></code> is the (approximate)
number of function calls per iteration of the <code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> algorithm
and <code class="docutils literal notranslate"><span class="pre">nitn</span></code> is the number of iterations. We use the integrator to
calculated the expectation value of <code class="docutils literal notranslate"><span class="pre">s*g</span></code> and <code class="docutils literal notranslate"><span class="pre">(s*g)**2</span></code> so we can
compute a mean and standard deviation.</p>
<p>The output from this code shows that the Gaussian approximation
for <code class="docutils literal notranslate"><span class="pre">s*g</span></code> (0.76(66)) is somewhat different from the result
obtained from a Bayesian integral (0.48(54)):</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Least</span> <span class="n">Square</span> <span class="n">Fit</span><span class="p">:</span>
  <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span> <span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.32</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.87</span>    <span class="n">logGBF</span> <span class="o">=</span> <span class="o">-</span><span class="mf">9.2027</span>

<span class="n">Parameters</span><span class="p">:</span>
              <span class="n">a</span>    <span class="mf">1.61</span> <span class="p">(</span><span class="mi">90</span><span class="p">)</span>     <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">5.0</span><span class="p">)</span> <span class="p">]</span>
              <span class="n">s</span>    <span class="mf">0.62</span> <span class="p">(</span><span class="mi">81</span><span class="p">)</span>     <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">2.0</span><span class="p">)</span> <span class="p">]</span>
              <span class="n">g</span>    <span class="mf">1.2</span> <span class="p">(</span><span class="mf">1.1</span><span class="p">)</span>     <span class="p">[</span>  <span class="mf">2.0</span> <span class="p">(</span><span class="mf">2.0</span><span class="p">)</span> <span class="p">]</span>

<span class="n">Settings</span><span class="p">:</span>
  <span class="n">svdcut</span><span class="o">/</span><span class="n">n</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="o">/</span><span class="mi">0</span>    <span class="n">reltol</span><span class="o">/</span><span class="n">abstol</span> <span class="o">=</span> <span class="mf">0.0001</span><span class="o">/</span><span class="mi">0</span><span class="o">*</span>    <span class="p">(</span><span class="n">itns</span><span class="o">/</span><span class="n">time</span> <span class="o">=</span> <span class="mi">10</span><span class="o">/</span><span class="mf">0.0</span><span class="p">)</span>

<span class="n">itn</span>   <span class="n">integral</span>        <span class="n">average</span>         <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span>        <span class="n">Q</span>
<span class="o">-------------------------------------------------------</span>
  <span class="mi">1</span>   <span class="mf">1.034</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>       <span class="mf">1.034</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>           <span class="mf">0.00</span>     <span class="mf">1.00</span>
  <span class="mi">2</span>   <span class="mf">1.034</span><span class="p">(</span><span class="mi">21</span><span class="p">)</span>       <span class="mf">1.034</span><span class="p">(</span><span class="mi">15</span><span class="p">)</span>           <span class="mf">0.56</span>     <span class="mf">0.64</span>
  <span class="mi">3</span>   <span class="mf">1.024</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>       <span class="mf">1.030</span><span class="p">(</span><span class="mi">12</span><span class="p">)</span>           <span class="mf">0.37</span>     <span class="mf">0.90</span>
  <span class="mi">4</span>   <span class="mf">1.010</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>       <span class="mf">1.0254</span><span class="p">(</span><span class="mi">98</span><span class="p">)</span>          <span class="mf">0.47</span>     <span class="mf">0.89</span>
  <span class="mi">5</span>   <span class="mf">1.005</span><span class="p">(</span><span class="mi">17</span><span class="p">)</span>       <span class="mf">1.0213</span><span class="p">(</span><span class="mi">85</span><span class="p">)</span>          <span class="mf">0.55</span>     <span class="mf">0.88</span>
  <span class="mi">6</span>   <span class="mf">1.013</span><span class="p">(</span><span class="mi">19</span><span class="p">)</span>       <span class="mf">1.0199</span><span class="p">(</span><span class="mi">78</span><span class="p">)</span>          <span class="mf">0.69</span>     <span class="mf">0.80</span>
  <span class="mi">7</span>   <span class="mf">0.987</span><span class="p">(</span><span class="mi">16</span><span class="p">)</span>       <span class="mf">1.0152</span><span class="p">(</span><span class="mi">70</span><span class="p">)</span>          <span class="mf">0.78</span>     <span class="mf">0.72</span>
  <span class="mi">8</span>   <span class="mf">1.002</span><span class="p">(</span><span class="mi">18</span><span class="p">)</span>       <span class="mf">1.0135</span><span class="p">(</span><span class="mi">66</span><span class="p">)</span>          <span class="mf">0.90</span>     <span class="mf">0.59</span>
  <span class="mi">9</span>   <span class="mf">1.036</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>       <span class="mf">1.0160</span><span class="p">(</span><span class="mi">62</span><span class="p">)</span>          <span class="mf">0.86</span>     <span class="mf">0.66</span>
 <span class="mi">10</span>   <span class="mf">1.060</span><span class="p">(</span><span class="mi">20</span><span class="p">)</span>       <span class="mf">1.0204</span><span class="p">(</span><span class="mi">60</span><span class="p">)</span>          <span class="mf">0.94</span>     <span class="mf">0.55</span>

<span class="n">results</span> <span class="o">=</span> <span class="p">[</span><span class="mf">0.4837</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span> <span class="mf">0.5259</span><span class="p">(</span><span class="mi">47</span><span class="p">)]</span>

<span class="n">s</span><span class="o">*</span><span class="n">g</span> <span class="kn">from</span> <span class="nn">Bayes</span> <span class="n">integral</span><span class="p">:</span>  <span class="n">mean</span> <span class="o">=</span> <span class="mf">0.4837</span><span class="p">(</span><span class="mi">32</span><span class="p">)</span>   <span class="n">sdev</span> <span class="o">=</span> <span class="mf">0.5403</span><span class="p">(</span><span class="mi">25</span><span class="p">)</span>
<span class="n">s</span><span class="o">*</span><span class="n">g</span> <span class="kn">from</span> <span class="nn">fit</span><span class="p">:</span> <span class="mf">0.78</span><span class="p">(</span><span class="mi">66</span><span class="p">)</span>
</pre></div>
</div>
<p>The table shows estimates of the probability density function’s
normalization from each of the <code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> iterations used
by the integrator to estimate the final results.</p>
<p>In general functions being integrated can return a number, or an array
of numbers, or a dictionary whose values are numbers or arrays of
numbers. This allows multiple expectation values to be evaluated
simultaneously.</p>
<p>See the documentation with the <code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> module for more details on
its use, and on the attributes and methods associated with
integrators. The example above sets <code class="docutils literal notranslate"><span class="pre">adapt=False</span></code> when  computing
final results. This gives more reliable error estimates  when
<code class="docutils literal notranslate"><span class="pre">neval</span></code> is small. Note that <code class="docutils literal notranslate"><span class="pre">neval</span></code> may need to be much larger
(tens or hundreds of thousands) for more difficult high-dimension
integrals.</p>
<dl class="method">
<dt id="lsqfit.BayesIntegrator.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>f=None</em>, <em>pdf=None</em>, <em>adapt_to_pdf=None</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.BayesIntegrator.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Estimate expectation value of function <code class="docutils literal notranslate"><span class="pre">f(p)</span></code>.</p>
<p>Uses multi-dimensional integration modules <code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code>  to
estimate the expectation value of <code class="docutils literal notranslate"><span class="pre">f(p)</span></code> with  respect to
the probability density function  associated with
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">nonlinear_fit</span></code></a> <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>f</strong> (<em>callable</em>) – Function <code class="docutils literal notranslate"><span class="pre">f(p)</span></code> to integrate. Integral is
the expectation value of the function with respect
to the distribution. The function can return a number,
an array of numbers, or a dictionary whose values are
numbers or arrays of numbers. Its argument <code class="docutils literal notranslate"><span class="pre">p</span></code>
has the same format as <code class="docutils literal notranslate"><span class="pre">self.fit.pmean</span></code> (that is,
either a number, an array, or a dictionary).
Omitting <code class="docutils literal notranslate"><span class="pre">f</span></code> (or setting it to <code class="docutils literal notranslate"><span class="pre">None</span></code>) implies that
only the PDF is integrated.</li>
<li><strong>pdf</strong> (<em>callable</em>) – Probability density function <code class="docutils literal notranslate"><span class="pre">pdf(p)</span></code> of the
fit parameters to use in place of the normal PDF associated
with the least-squares fit used to create the integrator.
The PDF need not be normalized; vegas will normalize it.
Ignored if <code class="docutils literal notranslate"><span class="pre">pdf=None</span></code> (the default).</li>
<li><strong>adapt_to_pdf</strong> (<em>bool</em>) – <code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> adapts to the PDF if
<code class="docutils literal notranslate"><span class="pre">True</span></code> (default); otherwise it adapts to <code class="docutils literal notranslate"><span class="pre">f(p)</span></code>
times the PDF.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>All other keyword arguments are passed on to a <code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code>
integrator; see the <code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> documentation for further
information.</p>
<p>The results returned are similar to what <code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> returns
but with an extra attribute: <code class="docutils literal notranslate"><span class="pre">results.norm</span></code>, which contains
the <code class="xref py py-mod docutils literal notranslate"><span class="pre">vegas</span></code> estimate for the norm of the PDF. This should
equal 1 within errors if the PDF is normalized (and so can serve
as a check on the integration in those cases).</p>
</dd></dl>

</dd></dl>

<p>A class that describes the Bayesian probability distribution associated
with a fit is:</p>
<dl class="class">
<dt id="lsqfit.BayesPDF">
<em class="property">class </em><code class="descclassname">lsqfit.</code><code class="descname">BayesPDF</code><span class="sig-paren">(</span><em>fit</em>, <em>svdcut=1e-15</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.BayesPDF" title="Permalink to this definition">¶</a></dt>
<dd><p>Bayesian probability density function corresponding to <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">nonlinear_fit</span></code></a> <code class="docutils literal notranslate"><span class="pre">fit</span></code>.</p>
<p>The probability density function is the exponential of
<code class="docutils literal notranslate"><span class="pre">-1/2</span></code> times the <code class="docutils literal notranslate"><span class="pre">chi**2</span></code> function (data and priors) used
in <code class="docutils literal notranslate"><span class="pre">fit</span></code> divided by <code class="docutils literal notranslate"><span class="pre">norm</span></code>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>fit</strong> – Fit from <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">nonlinear_fit</span></code></a>.</li>
<li><strong>svdcut</strong> (<em>non-negative float</em><em> or </em><em>None</em>) – If not <code class="docutils literal notranslate"><span class="pre">None</span></code>, replace
covariance matrix of <code class="docutils literal notranslate"><span class="pre">g</span></code> with a new matrix whose
small eigenvalues are modified: eigenvalues smaller than
<code class="docutils literal notranslate"><span class="pre">svdcut</span></code> times the maximum eigenvalue <code class="docutils literal notranslate"><span class="pre">eig_max</span></code> are
replaced by <code class="docutils literal notranslate"><span class="pre">svdcut*eig_max</span></code>. This can ameliorate
problems caused by roundoff errors when inverting the
covariance matrix. It increases the uncertainty associated
with the modified eigenvalues and so is conservative.
Setting <code class="docutils literal notranslate"><span class="pre">svdcut=None</span></code> or <code class="docutils literal notranslate"><span class="pre">svdcut=0</span></code> leaves the
covariance matrix unchanged. Default is <code class="docutils literal notranslate"><span class="pre">1e-12</span></code>.</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="lsqfit.BayesPDF.__call__">
<code class="descname">__call__</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.BayesPDF.__call__" title="Permalink to this definition">¶</a></dt>
<dd><p>Probability density function evaluated at <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
</dd></dl>

<dl class="method">
<dt id="lsqfit.BayesPDF.logpdf">
<code class="descname">logpdf</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.BayesPDF.logpdf" title="Permalink to this definition">¶</a></dt>
<dd><p>Logarithm of the probability density function evaluated at <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="lsqfit-multifitter-classes">
<h2><a class="reference internal" href="#lsqfit.MultiFitter" title="lsqfit.MultiFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter</span></code></a> Classes<a class="headerlink" href="#lsqfit-multifitter-classes" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#lsqfit.MultiFitter" title="lsqfit.MultiFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter</span></code></a> provides a framework for building component
systems to fit multiple pieces of data using a set of custom-designed models,
derived  from <a class="reference internal" href="#lsqfit.MultiFitterModel" title="lsqfit.MultiFitterModel"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitterModel</span></code></a>. Each model  encapsulates:
a) a particular fit function; b) a recipe for assembling the corresponding fit
data from a dictionary that contains all of the data; and c) a recipe for
assembling a fit prior drawn from a dictionary containing all the priors.
This allows fit problems to be broken down down into more manageable pieces,
which are then aggregated by <a class="reference internal" href="#lsqfit.MultiFitter" title="lsqfit.MultiFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter</span></code></a> into a single fit.</p>
<p>This framework was developed to support the <code class="xref py py-mod docutils literal notranslate"><span class="pre">corrfitter</span></code> module which is
used to analyze 2-point and 3-point correlators generated in Monte Carlo
simulations of quantum field theories (like QCD). The <code class="xref py py-mod docutils literal notranslate"><span class="pre">corrfitter</span></code>
module provides two models to describe correlators: <code class="xref py py-class docutils literal notranslate"><span class="pre">corrfitter.Corr2</span></code>
to describe one  2-point correlator, and <code class="xref py py-class docutils literal notranslate"><span class="pre">corrfitter.Corr3</span></code> to describe
one 3-point  correlator. A typical analysis involves fitting data for a mixture of
2-point and 3-point correlators, with sometimes hundreds of correlators in all.
Each correlator is described by either  a <code class="docutils literal notranslate"><span class="pre">Corr2</span></code> model or a <code class="docutils literal notranslate"><span class="pre">Corr3</span></code>
model. A list of models, one for each  correlator, is handed
<code class="xref py py-class docutils literal notranslate"><span class="pre">corrfitter.CorrFitter</span></code> (derived from  <a class="reference internal" href="#lsqfit.MultiFitter" title="lsqfit.MultiFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter</span></code></a>) to
fit the models to the correlator data. The models for different
correlators typically share many fit parameters.</p>
<p>A simpler example of a model is one that encapsulates
a linear fit function:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">import</span> <span class="nn">lsqfit</span>

<span class="k">class</span> <span class="nc">Linear</span><span class="p">(</span><span class="n">lsqfit</span><span class="o">.</span><span class="n">MultiFitterModel</span><span class="p">):</span>
    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">datatag</span><span class="p">,</span> <span class="n">x</span><span class="p">,</span> <span class="n">intercept</span><span class="p">,</span> <span class="n">slope</span><span class="p">):</span>
        <span class="nb">super</span><span class="p">(</span><span class="n">Linear</span><span class="p">,</span> <span class="bp">self</span><span class="p">)</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="n">datatag</span><span class="p">)</span>
        <span class="c1"># the independent variable</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">x</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">array</span><span class="p">(</span><span class="n">x</span><span class="p">)</span>
        <span class="c1"># keys used to find the intercept and slope in a parameter dictionary</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">intercept</span> <span class="o">=</span> <span class="n">intercept</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">slope</span> <span class="o">=</span> <span class="n">slope</span>

    <span class="k">def</span> <span class="nf">fitfcn</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">p</span><span class="p">):</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="k">return</span> <span class="n">p</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">]</span> <span class="o">+</span> <span class="n">p</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">]</span> <span class="o">*</span> <span class="bp">self</span><span class="o">.</span><span class="n">x</span>
        <span class="k">except</span> <span class="ne">KeyError</span><span class="p">:</span>
            <span class="c1"># slope parameter marginalized/omitted</span>
            <span class="k">return</span> <span class="nb">len</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">x</span><span class="p">)</span> <span class="o">*</span> <span class="p">[</span><span class="n">p</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">]]</span>

    <span class="k">def</span> <span class="nf">buildprior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">mopt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
        <span class="s2">&quot; Extract the model&#39;s parameters from prior. &quot;</span>
        <span class="n">newprior</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">newprior</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">]</span> <span class="o">=</span> <span class="n">prior</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">intercept</span><span class="p">]</span>
        <span class="k">if</span> <span class="n">mopt</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="c1"># slope parameter marginalized/omitted if mopt is not None</span>
            <span class="n">newprior</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">]</span> <span class="o">=</span> <span class="n">prior</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">slope</span><span class="p">]</span>
        <span class="k">return</span> <span class="n">newprior</span>

    <span class="k">def</span> <span class="nf">builddata</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">data</span><span class="p">):</span>
        <span class="s2">&quot; Extract the model&#39;s fit data from data. &quot;</span>
        <span class="k">return</span> <span class="n">data</span><span class="p">[</span><span class="bp">self</span><span class="o">.</span><span class="n">datatag</span><span class="p">]</span>
</pre></div>
</div>
<p>Imagine four sets of data, each corresponding to <code class="docutils literal notranslate"><span class="pre">x=1,2,3,4</span></code>, all of which
have the same intercept but different slopes:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">data</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span>
    <span class="n">d1</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;1.154(10)&#39;</span><span class="p">,</span> <span class="s1">&#39;2.107(16)&#39;</span><span class="p">,</span> <span class="s1">&#39;3.042(22)&#39;</span><span class="p">,</span> <span class="s1">&#39;3.978(29)&#39;</span><span class="p">],</span>
    <span class="n">d2</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;0.692(10)&#39;</span><span class="p">,</span> <span class="s1">&#39;1.196(16)&#39;</span><span class="p">,</span> <span class="s1">&#39;1.657(22)&#39;</span><span class="p">,</span> <span class="s1">&#39;2.189(29)&#39;</span><span class="p">],</span>
    <span class="n">d3</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;0.107(10)&#39;</span><span class="p">,</span> <span class="s1">&#39;0.030(16)&#39;</span><span class="p">,</span> <span class="s1">&#39;-0.027(22)&#39;</span><span class="p">,</span> <span class="s1">&#39;-0.149(29)&#39;</span><span class="p">],</span>
    <span class="n">d4</span><span class="o">=</span><span class="p">[</span><span class="s1">&#39;0.002(10)&#39;</span><span class="p">,</span> <span class="s1">&#39;-0.197(16)&#39;</span><span class="p">,</span> <span class="s1">&#39;-0.382(22)&#39;</span><span class="p">,</span> <span class="s1">&#39;-0.627(29)&#39;</span><span class="p">],</span>
    <span class="p">))</span>
</pre></div>
</div>
<p>To find the common intercept, we define a model for each set of
data:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">models</span> <span class="o">=</span> <span class="p">[</span>
   <span class="n">Linear</span><span class="p">(</span><span class="s1">&#39;d1&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">intercept</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">slope</span><span class="o">=</span><span class="s1">&#39;s1&#39;</span><span class="p">),</span>
   <span class="n">Linear</span><span class="p">(</span><span class="s1">&#39;d2&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">intercept</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">slope</span><span class="o">=</span><span class="s1">&#39;s2&#39;</span><span class="p">),</span>
   <span class="n">Linear</span><span class="p">(</span><span class="s1">&#39;d3&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">intercept</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">slope</span><span class="o">=</span><span class="s1">&#39;s3&#39;</span><span class="p">),</span>
   <span class="n">Linear</span><span class="p">(</span><span class="s1">&#39;d4&#39;</span><span class="p">,</span> <span class="n">x</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">],</span> <span class="n">intercept</span><span class="o">=</span><span class="s1">&#39;a&#39;</span><span class="p">,</span> <span class="n">slope</span><span class="o">=</span><span class="s1">&#39;s4&#39;</span><span class="p">),</span>
   <span class="p">]</span>
</pre></div>
</div>
<p>This says that <code class="docutils literal notranslate"><span class="pre">data['d3']</span></code>, for example, should be fit with  function
<code class="docutils literal notranslate"><span class="pre">p['a']</span> <span class="pre">+</span> <span class="pre">p['s3']</span> <span class="pre">*</span> <span class="pre">np.array([1,2,3,4])</span></code> where <code class="docutils literal notranslate"><span class="pre">p</span></code> is  a dictionary of fit
parameters.  The models here all share the same intercept, but have different
slopes. Assume that we know <em>a priori</em> that the intercept and slopes are all
order one:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">prior</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">gvar</span><span class="p">(</span><span class="nb">dict</span><span class="p">(</span><span class="n">a</span><span class="o">=</span><span class="s1">&#39;0(1)&#39;</span><span class="p">,</span> <span class="n">s1</span><span class="o">=</span><span class="s1">&#39;0(1)&#39;</span><span class="p">,</span> <span class="n">s2</span><span class="o">=</span><span class="s1">&#39;0(1)&#39;</span><span class="p">,</span> <span class="n">s3</span><span class="o">=</span><span class="s1">&#39;0(1)&#39;</span><span class="p">,</span> <span class="n">s4</span><span class="o">=</span><span class="s1">&#39;0(1)&#39;</span><span class="p">))</span>
</pre></div>
</div>
<p>Then we can fit all the data to determine the intercept:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fitter</span> <span class="o">=</span> <span class="n">lsqfit</span><span class="o">.</span><span class="n">MultiFitter</span><span class="p">(</span><span class="n">models</span><span class="o">=</span><span class="n">models</span><span class="p">)</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">lsqfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;intercept =&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>The output from this code is:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Least</span> <span class="n">Square</span> <span class="n">Fit</span><span class="p">:</span>
  <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span> <span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.49</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.95</span>    <span class="n">logGBF</span> <span class="o">=</span> <span class="mf">18.793</span>

<span class="n">Parameters</span><span class="p">:</span>
              <span class="n">a</span>    <span class="mf">0.2012</span> <span class="p">(</span><span class="mi">78</span><span class="p">)</span>      <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>
             <span class="n">s1</span>    <span class="mf">0.9485</span> <span class="p">(</span><span class="mi">53</span><span class="p">)</span>      <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>
             <span class="n">s2</span>    <span class="mf">0.4927</span> <span class="p">(</span><span class="mi">53</span><span class="p">)</span>      <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>
             <span class="n">s3</span>   <span class="o">-</span><span class="mf">0.0847</span> <span class="p">(</span><span class="mi">53</span><span class="p">)</span>      <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>
             <span class="n">s4</span>   <span class="o">-</span><span class="mf">0.2001</span> <span class="p">(</span><span class="mi">53</span><span class="p">)</span>      <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>

<span class="n">Settings</span><span class="p">:</span>
  <span class="n">svdcut</span><span class="o">/</span><span class="n">n</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="o">/</span><span class="mi">0</span>    <span class="n">tol</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e-08</span><span class="o">*</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">)</span>    <span class="p">(</span><span class="n">itns</span><span class="o">/</span><span class="n">time</span> <span class="o">=</span> <span class="mi">5</span><span class="o">/</span><span class="mf">0.0</span><span class="p">)</span>

<span class="n">intercept</span> <span class="o">=</span> <span class="mf">0.2012</span><span class="p">(</span><span class="mi">78</span><span class="p">)</span>
</pre></div>
</div>
<p>Model class <code class="docutils literal notranslate"><span class="pre">Linear</span></code> is configured to allow
marginalization of the slope parameter, if desired. Calling
<code class="docutils literal notranslate"><span class="pre">fitter.lsqfit(data=data,</span> <span class="pre">prior=prior,</span> <span class="pre">mopt=True)</span></code> moves the slope
parameters into the data (by subtracting <code class="docutils literal notranslate"><span class="pre">m.x</span> <span class="pre">*</span> <span class="pre">prior[m.slope]</span></code>
from the data for each model <code class="docutils literal notranslate"><span class="pre">m</span></code>), and does a single-parameter fit for the
intercept:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">Least</span> <span class="n">Square</span> <span class="n">Fit</span><span class="p">:</span>
  <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span> <span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.49</span> <span class="p">[</span><span class="mi">16</span><span class="p">]</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.95</span>    <span class="n">logGBF</span> <span class="o">=</span> <span class="mf">18.793</span>

<span class="n">Parameters</span><span class="p">:</span>
              <span class="n">a</span>   <span class="mf">0.2012</span> <span class="p">(</span><span class="mi">78</span><span class="p">)</span>     <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>

<span class="n">Settings</span><span class="p">:</span>
  <span class="n">svdcut</span><span class="o">/</span><span class="n">n</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="o">/</span><span class="mi">0</span>    <span class="n">tol</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e-08</span><span class="o">*</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">)</span>    <span class="p">(</span><span class="n">itns</span><span class="o">/</span><span class="n">time</span> <span class="o">=</span> <span class="mi">4</span><span class="o">/</span><span class="mf">0.0</span><span class="p">)</span>

<span class="n">intercept</span> <span class="o">=</span> <span class="mf">0.2012</span><span class="p">(</span><span class="mi">78</span><span class="p">)</span>
</pre></div>
</div>
<p>Marginalization can be useful when fitting large data sets since it
reduces the number of fit parameters and simplifies the fit.</p>
<p>Another variation is to replace the simultaneous fit of the four models
by a chained fit, where one model is fit at a time and its
results are fed into the next fit through that fit’s prior. Replacing the
fit code by</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="n">fitter</span> <span class="o">=</span> <span class="n">lsqfit</span><span class="o">.</span><span class="n">MultiFitter</span><span class="p">(</span><span class="n">models</span><span class="o">=</span><span class="n">models</span><span class="p">)</span>
<span class="n">fit</span> <span class="o">=</span> <span class="n">fitter</span><span class="o">.</span><span class="n">chained_lsqfit</span><span class="p">(</span><span class="n">data</span><span class="o">=</span><span class="n">data</span><span class="p">,</span> <span class="n">prior</span><span class="o">=</span><span class="n">prior</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">formatall</span><span class="p">())</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;intercept =&#39;</span><span class="p">,</span> <span class="n">fit</span><span class="o">.</span><span class="n">p</span><span class="p">[</span><span class="s1">&#39;a&#39;</span><span class="p">])</span>
</pre></div>
</div>
<p>gives the following output:</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="o">==========</span> <span class="n">d1</span>
<span class="n">Least</span> <span class="n">Square</span> <span class="n">Fit</span><span class="p">:</span>
  <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span> <span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.32</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.86</span>    <span class="n">logGBF</span> <span class="o">=</span> <span class="mf">2.0969</span>

<span class="n">Parameters</span><span class="p">:</span>
              <span class="n">a</span>    <span class="mf">0.213</span> <span class="p">(</span><span class="mi">16</span><span class="p">)</span>     <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>
             <span class="n">s1</span>   <span class="mf">0.9432</span> <span class="p">(</span><span class="mi">82</span><span class="p">)</span>     <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>

<span class="n">Settings</span><span class="p">:</span>
  <span class="n">svdcut</span><span class="o">/</span><span class="n">n</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="o">/</span><span class="mi">0</span>    <span class="n">tol</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e-08</span><span class="o">*</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">)</span>    <span class="p">(</span><span class="n">itns</span><span class="o">/</span><span class="n">time</span> <span class="o">=</span> <span class="mi">5</span><span class="o">/</span><span class="mf">0.0</span><span class="p">)</span>

<span class="o">==========</span> <span class="n">d2</span>
<span class="n">Least</span> <span class="n">Square</span> <span class="n">Fit</span><span class="p">:</span>
  <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span> <span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.58</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.67</span>    <span class="n">logGBF</span> <span class="o">=</span> <span class="mf">5.3792</span>

<span class="n">Parameters</span><span class="p">:</span>
              <span class="n">a</span>    <span class="mf">0.206</span> <span class="p">(</span><span class="mi">11</span><span class="p">)</span>     <span class="p">[</span> <span class="mf">0.213</span> <span class="p">(</span><span class="mi">16</span><span class="p">)</span> <span class="p">]</span>
             <span class="n">s2</span>   <span class="mf">0.4904</span> <span class="p">(</span><span class="mi">64</span><span class="p">)</span>     <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>

<span class="n">Settings</span><span class="p">:</span>
  <span class="n">svdcut</span><span class="o">/</span><span class="n">n</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="o">/</span><span class="mi">0</span>    <span class="n">tol</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e-08</span><span class="o">*</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">)</span>    <span class="p">(</span><span class="n">itns</span><span class="o">/</span><span class="n">time</span> <span class="o">=</span> <span class="mi">4</span><span class="o">/</span><span class="mf">0.0</span><span class="p">)</span>

<span class="o">==========</span> <span class="n">d3</span>
<span class="n">Least</span> <span class="n">Square</span> <span class="n">Fit</span><span class="p">:</span>
  <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span> <span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.66</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.62</span>    <span class="n">logGBF</span> <span class="o">=</span> <span class="mf">5.3767</span>

<span class="n">Parameters</span><span class="p">:</span>
              <span class="n">a</span>    <span class="mf">0.1995</span> <span class="p">(</span><span class="mi">90</span><span class="p">)</span>      <span class="p">[</span> <span class="mf">0.206</span> <span class="p">(</span><span class="mi">11</span><span class="p">)</span> <span class="p">]</span>
             <span class="n">s3</span>   <span class="o">-</span><span class="mf">0.0840</span> <span class="p">(</span><span class="mi">57</span><span class="p">)</span>      <span class="p">[</span>  <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>

<span class="n">Settings</span><span class="p">:</span>
  <span class="n">svdcut</span><span class="o">/</span><span class="n">n</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="o">/</span><span class="mi">0</span>    <span class="n">tol</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e-08</span><span class="o">*</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">)</span>    <span class="p">(</span><span class="n">itns</span><span class="o">/</span><span class="n">time</span> <span class="o">=</span> <span class="mi">4</span><span class="o">/</span><span class="mf">0.0</span><span class="p">)</span>

<span class="o">==========</span> <span class="n">d4</span>
<span class="n">Least</span> <span class="n">Square</span> <span class="n">Fit</span><span class="p">:</span>
  <span class="n">chi2</span><span class="o">/</span><span class="n">dof</span> <span class="p">[</span><span class="n">dof</span><span class="p">]</span> <span class="o">=</span> <span class="mf">0.41</span> <span class="p">[</span><span class="mi">4</span><span class="p">]</span>    <span class="n">Q</span> <span class="o">=</span> <span class="mf">0.81</span>    <span class="n">logGBF</span> <span class="o">=</span> <span class="mf">5.9402</span>

<span class="n">Parameters</span><span class="p">:</span>
              <span class="n">a</span>    <span class="mf">0.2012</span> <span class="p">(</span><span class="mi">78</span><span class="p">)</span>      <span class="p">[</span> <span class="mf">0.1995</span> <span class="p">(</span><span class="mi">90</span><span class="p">)</span> <span class="p">]</span>
             <span class="n">s4</span>   <span class="o">-</span><span class="mf">0.2001</span> <span class="p">(</span><span class="mi">53</span><span class="p">)</span>      <span class="p">[</span>   <span class="mf">0.0</span> <span class="p">(</span><span class="mf">1.0</span><span class="p">)</span> <span class="p">]</span>

<span class="n">Settings</span><span class="p">:</span>
  <span class="n">svdcut</span><span class="o">/</span><span class="n">n</span> <span class="o">=</span> <span class="mf">1e-12</span><span class="o">/</span><span class="mi">0</span>    <span class="n">tol</span> <span class="o">=</span> <span class="p">(</span><span class="mf">1e-08</span><span class="o">*</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">,</span><span class="mf">1e-10</span><span class="p">)</span>    <span class="p">(</span><span class="n">itns</span><span class="o">/</span><span class="n">time</span> <span class="o">=</span> <span class="mi">4</span><span class="o">/</span><span class="mf">0.0</span><span class="p">)</span>

<span class="n">intercept</span> <span class="o">=</span> <span class="mf">0.2012</span><span class="p">(</span><span class="mi">78</span><span class="p">)</span>
</pre></div>
</div>
<p>Note how the value for <code class="docutils literal notranslate"><span class="pre">a</span></code> improves with each fit.</p>
<p>Chained fits are most useful
with very large data sets when it is possible to break the data into
smaller, more manageable chunks. There are a variety of options for
organizing the chain of fits; these are discussed in the
<a class="reference internal" href="#lsqfit.MultiFitter.chained_lsqfit" title="lsqfit.MultiFitter.chained_lsqfit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.chained_lsqfit()</span></code></a> documentation.</p>
<dl class="class">
<dt id="lsqfit.MultiFitter">
<em class="property">class </em><code class="descclassname">lsqfit.</code><code class="descname">MultiFitter</code><span class="sig-paren">(</span><em>models</em>, <em>mopt=None</em>, <em>ratio=False</em>, <em>fast=True</em>, <em>**fitterargs</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitter" title="Permalink to this definition">¶</a></dt>
<dd><p>Nonlinear least-squares fitter for a collection of models.</p>
<p>Fits collections of data that are modeled by collections of models.
Fits can be simultaneous (<a class="reference internal" href="#lsqfit.MultiFitter.lsqfit" title="lsqfit.MultiFitter.lsqfit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lsqfit.MultiFitter.lsqfit()</span></code></a>) or chained
(<code class="xref py py-meth docutils literal notranslate"><span class="pre">lsqfit.MultiFitterl.chained_lsqfit()</span></code>).</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>models</strong> – List of models, derived from <a class="reference internal" href="#lsqfit.MultiFitterModel" title="lsqfit.MultiFitterModel"><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit.MultiFitterModel</span></code></a>,
to be fit to the data. Individual models in the list can
be replaced by lists of models or tuples of models; see below.</li>
<li><strong>mopt</strong> (<em>object</em>) – Marginalization options. If not <code class="docutils literal notranslate"><span class="pre">None</span></code>,
marginalization is used to reduce the number of fit parameters.
Object <code class="docutils literal notranslate"><span class="pre">mopt</span></code> is passed to the models when constructing the
prior for a fit; it typically indicates the degree of
marginalization (in a model-dependent fashion). Setting
<code class="docutils literal notranslate"><span class="pre">mopt=None</span></code> implies no marginalization.</li>
<li><strong>ratio</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code>, implement marginalization using
ratios: <code class="docutils literal notranslate"><span class="pre">data_marg</span> <span class="pre">=</span> <span class="pre">data</span> <span class="pre">*</span> <span class="pre">fitfcn(prior_marg)</span> <span class="pre">/</span> <span class="pre">fitfcn(prior)</span></code>.
If <code class="docutils literal notranslate"><span class="pre">False</span></code> (default), implement using differences:
<code class="docutils literal notranslate"><span class="pre">data_marg</span> <span class="pre">=</span> <span class="pre">data</span> <span class="pre">+</span> <span class="pre">(fitfcn(prior_marg)</span> <span class="pre">-</span> <span class="pre">fitfcn(prior))</span></code>.</li>
<li><strong>fast</strong> (<em>bool</em>) – Setting <code class="docutils literal notranslate"><span class="pre">fast=True</span></code> (default) strips any variable
not required by the fit from the prior. This speeds
fits but loses information about correlations between
variables in the fit and those that are not. Setting
<code class="docutils literal notranslate"><span class="pre">wavg_all=True</span></code> can restore some of the correlations, but
is somewhat slower.</li>
<li><strong>wavg_all</strong> (<em>bool</em>) – If <code class="docutils literal notranslate"><span class="pre">True</span></code> and <code class="docutils literal notranslate"><span class="pre">fast=True</span></code>, the final result of a
chained fit is the weighted average of all the fits in the chain.
This can restore correlations lost in the chain because
<code class="docutils literal notranslate"><span class="pre">fast=True</span></code>. This step is omitted if <code class="docutils literal notranslate"><span class="pre">wavg_all=False</span></code> or
<code class="docutils literal notranslate"><span class="pre">fast=False</span></code>. Default is <code class="docutils literal notranslate"><span class="pre">False</span></code>.</li>
<li><strong>fitname</strong> (callable or <code class="docutils literal notranslate"><span class="pre">None</span></code>) – Individual fits in a chained fit are
assigned default names, constructed from the datatags of
the corresponding models, for access and reporting. These names
get unwieldy when lots of models are involved. When <code class="docutils literal notranslate"><span class="pre">fitname</span></code>
is not <code class="docutils literal notranslate"><span class="pre">None</span></code> (default), each default name <code class="docutils literal notranslate"><span class="pre">dname</span></code> is
replaced by <code class="docutils literal notranslate"><span class="pre">fitname(dname)</span></code> which should return a string.</li>
<li><strong>wavg_kargs</strong> (<em>float</em>) – Keyword arguments for <a class="reference internal" href="#lsqfit.wavg" title="lsqfit.wavg"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lsqfit.wavg()</span></code></a> when
used to combine results from parallel sub-fits in a chained fit.</li>
<li><strong>fitterargs</strong> (<em>dict</em>) – Additional arguments for the
<a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> object used to do the fits.
These can be collected in a dictionary (e.g.,
<code class="docutils literal notranslate"><span class="pre">fitterargs=dict(tol=1e-6,</span> <span class="pre">maxit=500))</span></code>) or listed as
separate arguments (e.g., <code class="docutils literal notranslate"><span class="pre">tol=1e-6,</span> <span class="pre">maxit=500</span></code>).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="lsqfit.MultiFitter.lsqfit">
<code class="descname">lsqfit</code><span class="sig-paren">(</span><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitter.lsqfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute least-squares fit of models to data.</p>
<p><a class="reference internal" href="#lsqfit.MultiFitter.lsqfit" title="lsqfit.MultiFitter.lsqfit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.lsqfit()</span></code></a> fits all of the models together, in
a single fit. It returns the <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit</span></code></a> object from the fit.</p>
<p>To see plots of the fit data divided by the fit function
with the best-fit parameters use</p>
<blockquote>
<div>fit.show_plots()</div></blockquote>
<p>This method has optional keyword arguments <code class="docutils literal notranslate"><span class="pre">save</span></code> and <code class="docutils literal notranslate"><span class="pre">view</span></code>;
see documentation for <a class="reference internal" href="#lsqfit.MultiFitter.show_plots" title="lsqfit.MultiFitter.show_plots"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter.show_plots</span></code></a>
for more information. Plotting requires module <code class="xref py py-mod docutils literal notranslate"><span class="pre">matplotlib</span></code>.</p>
<p>To bootstrap a fit, use <code class="docutils literal notranslate"><span class="pre">fit.bootstrapped_fit_iter(...)</span></code>;
see <a class="reference internal" href="#lsqfit.nonlinear_fit.bootstrapped_fit_iter" title="lsqfit.nonlinear_fit.bootstrapped_fit_iter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit.bootstrapped_fit_iter()</span></code></a> for more
information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> – Input data. One of <code class="docutils literal notranslate"><span class="pre">data</span></code> or <code class="docutils literal notranslate"><span class="pre">pdata</span></code> must be
specified but not both. <code class="docutils literal notranslate"><span class="pre">pdata</span></code> is obtained from <code class="docutils literal notranslate"><span class="pre">data</span></code>
by collecting the output from <code class="docutils literal notranslate"><span class="pre">m.builddata(data)</span></code>
for each model <code class="docutils literal notranslate"><span class="pre">m</span></code> and storing it in a dictionary
with key <code class="docutils literal notranslate"><span class="pre">m.datatag</span></code>.</li>
<li><strong>pdata</strong> – Input data that has been processed by the
models using <a class="reference internal" href="#lsqfit.MultiFitter.process_data" title="lsqfit.MultiFitter.process_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.process_data()</span></code></a> or
<a class="reference internal" href="#lsqfit.MultiFitter.process_dataset" title="lsqfit.MultiFitter.process_dataset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.process_dataset()</span></code></a>. One of
<code class="docutils literal notranslate"><span class="pre">data</span></code> or <code class="docutils literal notranslate"><span class="pre">pdata</span></code> must be  specified but not both.</li>
<li><strong>prior</strong> (<em>dict</em>) – Bayesian prior for fit parameters used by the models.</li>
<li><strong>p0</strong> – Dictionary , indexed by parameter labels, containing
initial values for the parameters in the fit. Setting
<code class="docutils literal notranslate"><span class="pre">p0=None</span></code> implies that initial values are extracted from the
prior. Setting <code class="docutils literal notranslate"><span class="pre">p0=&quot;filename&quot;</span></code> causes the fitter to look in
the file with name <code class="docutils literal notranslate"><span class="pre">&quot;filename&quot;</span></code> for initial values and to
write out best-fit parameter values after the fit (for the
next call to <code class="docutils literal notranslate"><span class="pre">self.lsqfit()</span></code>).</li>
<li><strong>kargs</strong> – Arguments that (temporarily) override parameters specified
when the <a class="reference internal" href="#lsqfit.MultiFitter" title="lsqfit.MultiFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiFitter</span></code></a> was created. Can also include
additional arguments to be passed through to the <a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code></a>
fitter.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lsqfit.MultiFitter.chained_lsqfit">
<code class="descname">chained_lsqfit</code><span class="sig-paren">(</span><em>data=None</em>, <em>pdata=None</em>, <em>prior=None</em>, <em>p0=None</em>, <em>add_priornoise=None</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitter.chained_lsqfit" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute chained least-squares fit of models to data.</p>
<p>In a chained fit to models <code class="docutils literal notranslate"><span class="pre">[s1,</span> <span class="pre">s2,</span> <span class="pre">...]</span></code>, the models are fit one
at a time, with the fit output from one being fed into the prior for
the next. This can be much faster than  fitting the models together,
simultaneously. The final result comes from the last fit in the chain,
and includes parameters from all of the models.</p>
<p>The most general chain has the structure <code class="docutils literal notranslate"><span class="pre">[s1,</span> <span class="pre">s2,</span> <span class="pre">s3</span> <span class="pre">...]</span></code>
where each <code class="docutils literal notranslate"><span class="pre">sn</span></code> is one of:</p>
<blockquote>
<div><ol class="arabic simple">
<li>A model (derived from <code class="xref py py-class docutils literal notranslate"><span class="pre">multifitter.MultiFitterModel</span></code>).</li>
<li><dl class="first docutils">
<dt>A tuple <code class="docutils literal notranslate"><span class="pre">(m1,</span> <span class="pre">m2,</span> <span class="pre">m3)</span></code> of models, to be fit together in</dt>
<dd>a single fit (i.e., simultaneously). Simultaneous fits
are useful for closely related models.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>A list <code class="docutils literal notranslate"><span class="pre">[p1,</span> <span class="pre">p2,</span> <span class="pre">p3</span> <span class="pre">...]</span></code> where each <code class="docutils literal notranslate"><span class="pre">pn</span></code> is either</dt>
<dd>a model or a tuple of models (see #2). The <code class="docutils literal notranslate"><span class="pre">pn</span></code> are fit
separately: the fit output from one fit is <em>not</em> fed into the
prior of the next (i.e., the fits are effectively in
parallel). Results from the separate fits are averaged at the
end to provide a single composite result for the collection of
fits. Parallel fits are effective (and fast) when the
different fits have few or no fit parameters in common.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>A dictionary that (temporarily) resets default values for</dt>
<dd>fitter keywords. The new values, specified in the dictionary,
apply to subsequent fits in the chain. Any number of such
dictionaries can be included in the model chain.</dd>
</dl>
</li>
</ol>
</div></blockquote>
<p>Fit results are returned in a <code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter.chained_fit</span></code>
object <code class="docutils literal notranslate"><span class="pre">fit</span></code>, which is very similar to a <a class="reference internal" href="#lsqfit.nonlinear_fit" title="lsqfit.nonlinear_fit"><code class="xref py py-class docutils literal notranslate"><span class="pre">nonlinear_fit</span></code></a>
object (see documentation for more information). Object <code class="docutils literal notranslate"><span class="pre">fit</span></code> has an
extra attribute <code class="docutils literal notranslate"><span class="pre">fit.chained_fits</span></code> which is an ordered dictionary
containing fit results for each link in the chain of fits, indexed by
fit names built from the corresponding data tags.</p>
<p>To list results from all of the fits in the chain, use</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="nb">print</span><span class="p">(</span><span class="n">fit</span><span class="o">.</span><span class="n">formatall</span><span class="p">())</span>
</pre></div>
</div>
<p>This method has optional keyword arguments <code class="docutils literal notranslate"><span class="pre">maxline</span></code>,
<code class="docutils literal notranslate"><span class="pre">pstyle</span></code>, and <code class="docutils literal notranslate"><span class="pre">nline</span></code>; see the documentation for
<a class="reference internal" href="#lsqfit.nonlinear_fit.format" title="lsqfit.nonlinear_fit.format"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit.format()</span></code></a> for more
information.</p>
<p>To view plots of each fit use</p>
<blockquote>
<div>fit.show_plots()</div></blockquote>
<p>This method has optional keyword arguments <code class="docutils literal notranslate"><span class="pre">save</span></code> and <code class="docutils literal notranslate"><span class="pre">view</span></code>;
see documentation for <a class="reference internal" href="#lsqfit.MultiFitter.show_plots" title="lsqfit.MultiFitter.show_plots"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter.show_plots</span></code></a>
for more information. Plotting requires module <code class="xref py py-mod docutils literal notranslate"><span class="pre">matplotlib</span></code>.</p>
<p>To bootstrap a fit, use <code class="docutils literal notranslate"><span class="pre">fit.bootstrapped_fit_iter(...)</span></code>;
see <a class="reference internal" href="#lsqfit.nonlinear_fit.bootstrapped_fit_iter" title="lsqfit.nonlinear_fit.bootstrapped_fit_iter"><code class="xref py py-meth docutils literal notranslate"><span class="pre">lsqfit.nonlinear_fit.bootstrapped_fit_iter()</span></code></a> for more
information.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>data</strong> – Input data. One of <code class="docutils literal notranslate"><span class="pre">data</span></code> or <code class="docutils literal notranslate"><span class="pre">pdata</span></code> must be
specified but not both. <code class="docutils literal notranslate"><span class="pre">pdata</span></code> is obtained from <code class="docutils literal notranslate"><span class="pre">data</span></code>
by collecting the output from <code class="docutils literal notranslate"><span class="pre">m.builddata(data)</span></code>
for each model <code class="docutils literal notranslate"><span class="pre">m</span></code> and storing it in a dictionary
with key <code class="docutils literal notranslate"><span class="pre">m.datatag</span></code>.</li>
<li><strong>pdata</strong> – Input data that has been processed by the
models using <a class="reference internal" href="#lsqfit.MultiFitter.process_data" title="lsqfit.MultiFitter.process_data"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.process_data()</span></code></a> or
<a class="reference internal" href="#lsqfit.MultiFitter.process_dataset" title="lsqfit.MultiFitter.process_dataset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.process_dataset()</span></code></a>. One of
<code class="docutils literal notranslate"><span class="pre">data</span></code> or <code class="docutils literal notranslate"><span class="pre">pdata</span></code> must be  specified but not both.</li>
<li><strong>prior</strong> – Bayesian prior for fit parameters used by the models.</li>
<li><strong>p0</strong> – Dictionary , indexed by parameter labels, containing
initial values for the parameters in the fit. Setting
<code class="docutils literal notranslate"><span class="pre">p0=None</span></code> implies that initial values are extracted from the
prior. Setting <code class="docutils literal notranslate"><span class="pre">p0=&quot;filename&quot;</span></code> causes the fitter to look in
the file with name <code class="docutils literal notranslate"><span class="pre">&quot;filename&quot;</span></code> for initial values and to
write out best-fit parameter values after the fit (for the
next call to <code class="docutils literal notranslate"><span class="pre">self.lsqfit()</span></code>).</li>
<li><strong>kargs</strong> – Arguments that override parameters specified when
the <a class="reference internal" href="#lsqfit.MultiFitter" title="lsqfit.MultiFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">MultiFitter</span></code></a> was created. Can also include
additional arguments to be passed through to
the <a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code></a> fitter.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lsqfit.MultiFitter.set">
<code class="descname">set</code><span class="sig-paren">(</span><em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitter.set" title="Permalink to this definition">¶</a></dt>
<dd><p>Reset default keyword parameters.</p>
<p>Assigns new default values from dictionary <code class="docutils literal notranslate"><span class="pre">kargs</span></code> to the fitter’s
keyword parameters. Keywords for the underlying <a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code></a> fitters
can also be  included (or grouped together in dictionary
<code class="docutils literal notranslate"><span class="pre">fitterargs</span></code>).</p>
<p>Returns tuple <code class="docutils literal notranslate"><span class="pre">(kargs,</span> <span class="pre">oldkargs)</span></code> where <code class="docutils literal notranslate"><span class="pre">kargs</span></code> is a dictionary
containing all <a class="reference internal" href="#lsqfit.MultiFitter" title="lsqfit.MultiFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter</span></code></a> keywords after they have
been updated, and <code class="docutils literal notranslate"><span class="pre">oldkargs</span></code> contains the  original values for these
keywords. Use <code class="docutils literal notranslate"><span class="pre">fitter.set(**oldkargs)</span></code> to restore the original
values.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="lsqfit.MultiFitter.process_data">
<em class="property">static </em><code class="descname">process_data</code><span class="sig-paren">(</span><em>data</em>, <em>models</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitter.process_data" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert <code class="docutils literal notranslate"><span class="pre">data</span></code> to processed data using <code class="docutils literal notranslate"><span class="pre">models</span></code>.</p>
<p>Data from dictionary <code class="docutils literal notranslate"><span class="pre">data</span></code> is processed by each model
in list <code class="docutils literal notranslate"><span class="pre">models</span></code>, and the results collected into a new
dictionary <code class="docutils literal notranslate"><span class="pre">pdata</span></code> for use in <a class="reference internal" href="#lsqfit.MultiFitter.lsqfit" title="lsqfit.MultiFitter.lsqfit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.lsqfit()</span></code></a>
and <code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.chained_lsqft()</span></code>.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="lsqfit.MultiFitter.process_dataset">
<em class="property">static </em><code class="descname">process_dataset</code><span class="sig-paren">(</span><em>dataset</em>, <em>models</em>, <em>**kargs</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitter.process_dataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Convert <code class="docutils literal notranslate"><span class="pre">dataset</span></code> to processed data using <code class="docutils literal notranslate"><span class="pre">models</span></code>.</p>
<p><code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.dataset.Dataset</span></code> (or similar dictionary) object
<code class="docutils literal notranslate"><span class="pre">dataset</span></code> is processed by each model in list <code class="docutils literal notranslate"><span class="pre">models</span></code>,
and the results collected into a new dictionary <code class="docutils literal notranslate"><span class="pre">pdata</span></code> for use in
<a class="reference internal" href="#lsqfit.MultiFitter.lsqfit" title="lsqfit.MultiFitter.lsqfit"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.lsqfit()</span></code></a> and <code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.chained_lsqft()</span></code>.
Assumes that the models have defined method
<a class="reference internal" href="#lsqfit.MultiFitterModel.builddataset" title="lsqfit.MultiFitterModel.builddataset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitterModel.builddataset()</span></code></a>. Keyword arguments
<code class="docutils literal notranslate"><span class="pre">kargs</span></code> are passed on to <code class="xref py py-func docutils literal notranslate"><span class="pre">gvar.dataset.avg_data()</span></code> when
averaging the data.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="lsqfit.MultiFitter.show_plots">
<em class="property">static </em><code class="descname">show_plots</code><span class="sig-paren">(</span><em>fitdata</em>, <em>fitval</em>, <em>x=None</em>, <em>save=False</em>, <em>view='ratio'</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitter.show_plots" title="Permalink to this definition">¶</a></dt>
<dd><p>Show plots comparing <code class="docutils literal notranslate"><span class="pre">fitdata[k],fitval[k]</span></code> for each key <code class="docutils literal notranslate"><span class="pre">k</span></code> in <code class="docutils literal notranslate"><span class="pre">fitval</span></code>.</p>
<p>Assumes <code class="xref py py-mod docutils literal notranslate"><span class="pre">matplotlib</span></code> is installed (to make the plots). Plots
are shown for one correlator at a time. Press key <code class="docutils literal notranslate"><span class="pre">n</span></code> to see the
next correlator; press key <code class="docutils literal notranslate"><span class="pre">p</span></code> to see the previous one; press key
<code class="docutils literal notranslate"><span class="pre">q</span></code> to quit the plot and return control to the calling program;
press a digit to go directly to one of the first ten plots. Zoom,
pan and save using the window controls.</p>
<p>There are several different views available for each plot,
specified by parameter <code class="docutils literal notranslate"><span class="pre">view</span></code>:</p>
<blockquote>
<div><p><code class="docutils literal notranslate"><span class="pre">view='ratio'</span></code>: Data divided by fit (default).</p>
<p><code class="docutils literal notranslate"><span class="pre">view='diff'</span></code>: Data minus fit, divided by data’s standard deviation.</p>
<p><code class="docutils literal notranslate"><span class="pre">view='std'</span></code>: Data and fit.</p>
<p><code class="docutils literal notranslate"><span class="pre">view='log'</span></code>: <code class="docutils literal notranslate"><span class="pre">'std'</span></code> with log scale on the vertical axis.</p>
<p><code class="docutils literal notranslate"><span class="pre">view='loglog'</span></code>: <cite>‘std’`</cite> with log scale on both axes.</p>
</div></blockquote>
<p>Press key <code class="docutils literal notranslate"><span class="pre">v</span></code> to cycle through these  views; or press keys
<code class="docutils literal notranslate"><span class="pre">r</span></code>, <code class="docutils literal notranslate"><span class="pre">d</span></code>, or <code class="docutils literal notranslate"><span class="pre">l</span></code> for the <code class="docutils literal notranslate"><span class="pre">'ratio'</span></code>, <code class="docutils literal notranslate"><span class="pre">'diff'</span></code>,
or <code class="docutils literal notranslate"><span class="pre">'log'</span></code> views, respectively.</p>
<p>Copies of the plots that are viewed can be saved by setting parameter
<code class="docutils literal notranslate"><span class="pre">save=fmt</span></code> where <code class="docutils literal notranslate"><span class="pre">fmt</span></code> is a string used to create
file names: the file name for the plot corresponding to key
<code class="docutils literal notranslate"><span class="pre">k</span></code> is <code class="docutils literal notranslate"><span class="pre">fmt.format(k)</span></code>. It is important that the
filename end with a suffix indicating the type of plot file
desired: e.g., <code class="docutils literal notranslate"><span class="pre">fmt='plot-{}.pdf'</span></code>.</p>
</dd></dl>

<dl class="staticmethod">
<dt id="lsqfit.MultiFitter.flatten_models">
<em class="property">static </em><code class="descname">flatten_models</code><span class="sig-paren">(</span><em>models</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitter.flatten_models" title="Permalink to this definition">¶</a></dt>
<dd><p>Create 1d-array containing all disctinct models from <code class="docutils literal notranslate"><span class="pre">models</span></code>.</p>
</dd></dl>

</dd></dl>

<p><a class="reference internal" href="#lsqfit.MultiFitter" title="lsqfit.MultiFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter</span></code></a> models are derived from the following
class. Methods <code class="docutils literal notranslate"><span class="pre">buildprior</span></code>, <code class="docutils literal notranslate"><span class="pre">builddata</span></code>, <code class="docutils literal notranslate"><span class="pre">fitfcn</span></code>, and
<code class="docutils literal notranslate"><span class="pre">builddataset</span></code> are not implemented in this base
class. They need to be overwritten by the derived class (except
for <code class="docutils literal notranslate"><span class="pre">builddataset</span></code> which is optional).</p>
<dl class="class">
<dt id="lsqfit.MultiFitterModel">
<em class="property">class </em><code class="descclassname">lsqfit.</code><code class="descname">MultiFitterModel</code><span class="sig-paren">(</span><em>datatag</em>, <em>ncg=1</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitterModel" title="Permalink to this definition">¶</a></dt>
<dd><p>Base class for MultiFitter models.</p>
<p>Derived classes must define methods <code class="docutils literal notranslate"><span class="pre">fitfcn</span></code>, <code class="docutils literal notranslate"><span class="pre">buildprior</span></code>, and
<code class="docutils literal notranslate"><span class="pre">builddata</span></code>, all of which are described below. In addition they
have attributes:</p>
<dl class="attribute">
<dt id="lsqfit.MultiFitterModel.datatag">
<code class="descname">datatag</code><a class="headerlink" href="#lsqfit.MultiFitterModel.datatag" title="Permalink to this definition">¶</a></dt>
<dd><p><a class="reference internal" href="#lsqfit.MultiFitter" title="lsqfit.MultiFitter"><code class="xref py py-class docutils literal notranslate"><span class="pre">lsqfit.MultiFitter</span></code></a> builds fit data for the correlator by
extracting the data labelled by <code class="docutils literal notranslate"><span class="pre">datatag</span></code> (eg, a string) from an
input data set (eg, a dictionary). This label is stored in the
<code class="docutils literal notranslate"><span class="pre">MultiFitterModel</span></code> and must be passed to its constructor. It must be
a hashable quantity, like a string or number or tuple of strings and
numbers.</p>
</dd></dl>

<dl class="attribute">
<dt id="lsqfit.MultiFitterModel.ncg">
<code class="descname">ncg</code><a class="headerlink" href="#lsqfit.MultiFitterModel.ncg" title="Permalink to this definition">¶</a></dt>
<dd><p>When <code class="docutils literal notranslate"><span class="pre">ncg&gt;1</span></code>, fit data and functions are coarse-grained by
breaking them up into bins of of <code class="docutils literal notranslate"><span class="pre">ncg</span></code> values and replacing
each bin by its average. This can increase the fitting speed,
because there is less data, without much loss of precision
if the data elements within a bin are highly correlated.</p>
</dd></dl>

<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>datatag</strong> – Label used to identify model’s data.</li>
<li><strong>ncg</strong> (<em>int</em>) – Size of bins for coarse graining (default is <code class="docutils literal notranslate"><span class="pre">ncg=1</span></code>).</li>
</ul>
</td>
</tr>
</tbody>
</table>
<dl class="method">
<dt id="lsqfit.MultiFitterModel.buildprior">
<code class="descname">buildprior</code><span class="sig-paren">(</span><em>prior</em>, <em>mopt=None</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitterModel.buildprior" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract fit prior from <code class="docutils literal notranslate"><span class="pre">prior</span></code>.</p>
<p>Returns a dictionary containing the  part of dictionary
<code class="docutils literal notranslate"><span class="pre">prior</span></code> that is relevant to this model’s fit. The code could
be as simple as collecting the appropriate pieces: e.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">buildprior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">mopt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">mprior</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">BufferDict</span><span class="p">()</span>
    <span class="n">model_keys</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">model_keys</span><span class="p">:</span>
        <span class="n">mprior</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">prior</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">mprior</span>
</pre></div>
</div>
<p>where <code class="docutils literal notranslate"><span class="pre">model_keys</span></code> is a list of keys corresponding to
the model’s parameters. Supporting non-Gaussian distributions
requires a slight modification: e.g.,</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="k">def</span> <span class="nf">buildprior</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">prior</span><span class="p">,</span> <span class="n">mopt</span><span class="o">=</span><span class="kc">None</span><span class="p">):</span>
    <span class="n">mprior</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">BufferDict</span><span class="p">()</span>
    <span class="n">model_keys</span> <span class="o">=</span> <span class="p">[</span><span class="o">...</span><span class="p">]</span>
    <span class="k">for</span> <span class="n">k</span> <span class="ow">in</span> <span class="n">gv</span><span class="o">.</span><span class="n">get_dictkeys</span><span class="p">(</span><span class="n">prior</span><span class="p">,</span> <span class="n">model_keys</span><span class="p">):</span>
        <span class="n">mprior</span><span class="p">[</span><span class="n">k</span><span class="p">]</span> <span class="o">=</span> <span class="n">prior</span><span class="p">[</span><span class="n">k</span><span class="p">]</span>
    <span class="k">return</span> <span class="n">mprior</span>
</pre></div>
</div>
<p>Marginalization involves omitting some of the fit parameters from the
model’s prior. <code class="docutils literal notranslate"><span class="pre">mopt=None</span></code> implies no marginalization. Otherwise
<code class="docutils literal notranslate"><span class="pre">mopt</span></code> will typically contain information about what and how much
to marginalize.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><ul class="first last simple">
<li><strong>prior</strong> – Dictionary containing <em>a priori</em> estimates of all
fit parameters.</li>
<li><strong>mopt</strong> (<em>object</em>) – Marginalization options. Ignore if <code class="docutils literal notranslate"><span class="pre">None</span></code>.
Otherwise marginalize fit parameters as specified by <code class="docutils literal notranslate"><span class="pre">mopt</span></code>.
<code class="docutils literal notranslate"><span class="pre">mopt</span></code> can be any type of Python object; it is used only
in <code class="docutils literal notranslate"><span class="pre">buildprior</span></code> and is passed through to it unchanged.</li>
</ul>
</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lsqfit.MultiFitterModel.builddata">
<code class="descname">builddata</code><span class="sig-paren">(</span><em>data</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitterModel.builddata" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract fit data corresponding to this model from data set <code class="docutils literal notranslate"><span class="pre">data</span></code>.</p>
<p>The fit data is returned in a 1-dimensional array;
the fitfcn must return arrays of the same length.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>data</strong> – Data set containing the fit data for all models. This
is typically a dictionary, whose keys are the <code class="docutils literal notranslate"><span class="pre">datatag</span></code>s
of the models.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lsqfit.MultiFitterModel.fitfcn">
<code class="descname">fitfcn</code><span class="sig-paren">(</span><em>p</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitterModel.fitfcn" title="Permalink to this definition">¶</a></dt>
<dd><p>Compute fit function fit for parameters <code class="docutils literal notranslate"><span class="pre">p</span></code>.</p>
<p>Results are returned in a 1-dimensional array the
same length as (and corresponding to) the fit data
returned by <code class="docutils literal notranslate"><span class="pre">self.builddata(data)</span></code>.</p>
<p>If marginalization is supported, <code class="docutils literal notranslate"><span class="pre">fitfcn</span></code> must work
with or without the marginalized parameters.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>p</strong> – Dictionary of parameter values.</td>
</tr>
</tbody>
</table>
</dd></dl>

<dl class="method">
<dt id="lsqfit.MultiFitterModel.builddataset">
<code class="descname">builddataset</code><span class="sig-paren">(</span><em>dataset</em><span class="sig-paren">)</span><a class="headerlink" href="#lsqfit.MultiFitterModel.builddataset" title="Permalink to this definition">¶</a></dt>
<dd><p>Extract fit dataset from <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.dataset.Dataset</span></code> <code class="docutils literal notranslate"><span class="pre">dataset</span></code>.</p>
<p>The code</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">gv</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">avg_data</span><span class="p">(</span><span class="n">m</span><span class="o">.</span><span class="n">builddataset</span><span class="p">(</span><span class="n">dataset</span><span class="p">))</span>
</pre></div>
</div>
<p>that builds data for model <code class="docutils literal notranslate"><span class="pre">m</span></code> should be functionally
equivalent to</p>
<div class="highlight-default notranslate"><div class="highlight"><pre><span></span><span class="kn">import</span> <span class="nn">gvar</span> <span class="k">as</span> <span class="nn">gv</span>

<span class="n">data</span> <span class="o">=</span> <span class="n">m</span><span class="o">.</span><span class="n">builddata</span><span class="p">(</span><span class="n">gv</span><span class="o">.</span><span class="n">dataset</span><span class="o">.</span><span class="n">avg_data</span><span class="p">(</span><span class="n">dataset</span><span class="p">))</span>
</pre></div>
</div>
<p>This method is optional. It is used only by
<a class="reference internal" href="#lsqfit.MultiFitter.process_dataset" title="lsqfit.MultiFitter.process_dataset"><code class="xref py py-meth docutils literal notranslate"><span class="pre">MultiFitter.process_dataset()</span></code></a>.</p>
<table class="docutils field-list" frame="void" rules="none">
<col class="field-name" />
<col class="field-body" />
<tbody valign="top">
<tr class="field-odd field"><th class="field-name">Parameters:</th><td class="field-body"><strong>dataset</strong> – <code class="xref py py-class docutils literal notranslate"><span class="pre">gvar.dataset.Dataset</span></code> (or similar dictionary)
dataset containing the fit data for all models. This is
typically a dictionary, whose keys are the <code class="docutils literal notranslate"><span class="pre">datatag</span></code>s of
the models.</td>
</tr>
</tbody>
</table>
</dd></dl>

</dd></dl>

</div>
<div class="section" id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#module-lsqfit" title="lsqfit: Nonlinear least squares fitting."><code class="xref py py-mod docutils literal notranslate"><span class="pre">lsqfit</span></code></a> relies heavily on the <code class="xref py py-mod docutils literal notranslate"><span class="pre">gvar</span></code>, and <code class="xref py py-mod docutils literal notranslate"><span class="pre">numpy</span></code> modules.
Also the fitting and minimization routines are from
the Gnu Scientific Library (GSL) and/or the Python <code class="xref py py-mod docutils literal notranslate"><span class="pre">scipy</span></code> module.</p>
</div>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
  <h3><a href="index.html">Table Of Contents</a></h3>
  <ul>
<li><a class="reference internal" href="#"><code class="docutils literal notranslate"><span class="pre">lsqfit</span></code> - Nonlinear Least Squares Fitting</a><ul>
<li><a class="reference internal" href="#introduction">Introduction</a></li>
<li><a class="reference internal" href="#nonlinear-fit-objects">nonlinear_fit Objects</a></li>
<li><a class="reference internal" href="#functions">Functions</a></li>
<li><a class="reference internal" href="#classes-for-bayesian-integrals">Classes for Bayesian Integrals</a></li>
<li><a class="reference internal" href="#lsqfit-multifitter-classes"><code class="docutils literal notranslate"><span class="pre">lsqfit.MultiFitter</span></code> Classes</a></li>
<li><a class="reference internal" href="#requirements">Requirements</a></li>
</ul>
</li>
</ul>

  <h4>Previous topic</h4>
  <p class="topless"><a href="case-outliers.html"
                        title="previous chapter">Case Study: Outliers and Bayesian Integrals</a></p>
  <h4>Next topic</h4>
  <p class="topless"><a href="gsl.html"
                        title="next chapter">GSL Routines</a></p>
  <div role="note" aria-label="source link">
    <h3>This Page</h3>
    <ul class="this-page-menu">
      <li><a href="_sources/lsqfit.rst.txt"
            rel="nofollow">Show Source</a></li>
    </ul>
   </div>
<div id="searchbox" style="display: none" role="search">
  <h3>Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="search.html" method="get">
      <input type="text" name="q" />
      <input type="submit" value="Go" />
      <input type="hidden" name="check_keywords" value="yes" />
      <input type="hidden" name="area" value="default" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             >index</a></li>
        <li class="right" >
          <a href="py-modindex.html" title="Python Module Index"
             >modules</a> |</li>
        <li class="right" >
          <a href="gsl.html" title="GSL Routines"
             >next</a> |</li>
        <li class="right" >
          <a href="case-outliers.html" title="Case Study: Outliers and Bayesian Integrals"
             >previous</a> |</li>
        <li class="nav-item nav-item-0"><a href="index.html">lsqfit 11.2 documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        &#169; Copyright 2009-2019, G. P. Lepage.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.4.
    </div>
  </body>
</html>